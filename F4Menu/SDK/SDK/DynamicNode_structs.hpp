#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DynamicNode

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "Engine_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"
#include "AnimationCore_structs.hpp"


namespace SDK
{

// Enum DynamicNode.EAnimationProcessingTypes
// NumValues: 0x0004
enum class EAnimationProcessingTypes : uint8
{
	None                                     = 0,
	WeakProc                                 = 1,
	FullProc                                 = 2,
	EAnimationProcessingTypes_MAX            = 3,
};

// Enum DynamicNode.EBlendSpace2DMode_DN
// NumValues: 0x0007
enum class EBlendSpace2DMode_DN : uint8
{
	VelocityAndControlRot180XSpeed           = 0,
	VelocityAndActorRot180XSpeed             = 1,
	InputAndActorRot90XSpeed                 = 2,
	VelocityAndActorRot90XSpeed              = 3,
	InputAndActorRot90X90                    = 4,
	VelocityAndActorRot90X90                 = 5,
	EBlendSpace2DMode_MAX                    = 6,
};

// Enum DynamicNode.EHandsCCDIKAlignType_DN
// NumValues: 0x0003
enum class EHandsCCDIKAlignType_DN : uint8
{
	OnlyInitial                              = 0,
	Tracking                                 = 1,
	EHandsCCDIKAlignType_MAX                 = 2,
};

// Enum DynamicNode.EReplicationType_DN
// NumValues: 0x0003
enum class EReplicationType_DN : uint8
{
	ServerMain                               = 0,
	OwnClientMain                            = 1,
	EReplicationType_MAX                     = 2,
};

// Enum DynamicNode.EMeshForwardAxis_DN
// NumValues: 0x0003
enum class EMeshForwardAxis_DN : uint8
{
	X                                        = 0,
	Y                                        = 1,
	EMeshForwardAxis_MAX                     = 2,
};

// Enum DynamicNode.EStoppingAnimProcType_DN
// NumValues: 0x0003
enum class EStoppingAnimProcType_DN : uint8
{
	Direction                                = 0,
	Position                                 = 1,
	EStoppingAnimProcType_MAX                = 2,
};

// Enum DynamicNode.EAnimationReturnTypes_DN
// NumValues: 0x0007
enum class EAnimationReturnTypes_DN : uint8
{
	Skiped                                   = 0,
	Accepted                                 = 1,
	Finished                                 = 2,
	Moved                                    = 3,
	Event                                    = 4,
	Error                                    = 5,
	EAnimationReturnTypes_MAX                = 6,
};

// Enum DynamicNode.EPropsActorPosition_DN
// NumValues: 0x0004
enum class EPropsActorPosition_DN : uint8
{
	StartPosition                            = 0,
	FinalPosition                            = 1,
	IntermediatePosition                     = 2,
	EPropsActorPosition_MAX                  = 3,
};

// Enum DynamicNode.EAutoCalculateAngle_DN
// NumValues: 0x0005
enum class EAutoCalculateAngle_DN : uint8
{
	Disabled                                 = 0,
	OnlyYaw                                  = 1,
	OnlyYaw_KeepInitYawAngle                 = 2,
	Enabled                                  = 3,
	EAutoCalculateAngle_MAX                  = 4,
};

// Enum DynamicNode.EHandleType_DN
// NumValues: 0x0005
enum class EHandleType_DN : uint8
{
	ForwardStart                             = 0,
	ForwardFinal                             = 1,
	ReverseStart                             = 2,
	ReverseFinal                             = 3,
	MAX                                      = 4,
};

// Enum DynamicNode.ETrackingTypeWhenFollow_DN
// NumValues: 0x0004
enum class ETrackingTypeWhenFollow_DN : uint8
{
	Always                                   = 0,
	Always_OnlyIfTargetActorDontMove         = 1,
	OnlyIfTargetSocketInRadius               = 2,
	MAX                                      = 3,
};

// Enum DynamicNode.EInterruptBehaviorFollowActor_DN
// NumValues: 0x0005
enum class EInterruptBehaviorFollowActor_DN : uint8
{
	FinishMove                               = 0,
	StopMove                                 = 1,
	StopMove_WNextReverse                    = 2,
	ReverseMove                              = 3,
	MAX                                      = 4,
};

// Enum DynamicNode.EInterpolationBlend_DN
// NumValues: 0x0008
enum class EInterpolationBlend_DN : uint8
{
	Linear                                   = 0,
	Cubic                                    = 1,
	Sinusoidal                               = 2,
	EaseInOutExponent2                       = 3,
	EaseInOutExponent3                       = 4,
	EaseInOutExponent4                       = 5,
	EaseInOutExponent5                       = 6,
	MAX                                      = 7,
};

// Enum DynamicNode.EBranchesEOutEnum_DN
// NumValues: 0x0003
enum class EBranchesEOutEnum_DN : uint8
{
	Disabled                                 = 0,
	Enabled                                  = 1,
	EBranchesEOutEnum_MAX                    = 2,
};

// Enum DynamicNode.ESwimmingStatus_DN
// NumValues: 0x0007
enum class ESwimmingStatus_DN : uint8
{
	Fail                                     = 0,
	SwimmFromVel                             = 1,
	SwimmFromAcc                             = 2,
	SurfaceSwimmFromVel                      = 3,
	SurfaceSwimmFromAcc                      = 4,
	ShallowWaterWalking                      = 5,
	ESwimmingStatus_MAX                      = 6,
};

// Enum DynamicNode.EAccelerationStatus_DN
// NumValues: 0x0004
enum class EAccelerationStatus_DN : uint8
{
	Fail                                     = 0,
	FromVel                                  = 1,
	FromAcc                                  = 2,
	EAccelerationStatus_MAX                  = 3,
};

// Enum DynamicNode.ERearSocketWeightSlopeType_DN
// NumValues: 0x0004
enum class ERearSocketWeightSlopeType_DN : uint8
{
	SlopeDown                                = 0,
	SlopeUp                                  = 1,
	All                                      = 2,
	ERearSocketWeightSlopeType_MAX           = 3,
};

// Enum DynamicNode.EBranchesOutEnum
// NumValues: 0x0003
enum class EBranchesOutEnum : uint8
{
	Success                                  = 0,
	Fail                                     = 1,
	EBranchesOutEnum_MAX                     = 2,
};

// Enum DynamicNode.ESlopeStatus_DN
// NumValues: 0x0004
enum class ESlopeStatus_DN : uint8
{
	NoSlope                                  = 0,
	SlopeUp                                  = 1,
	SlopeDown                                = 2,
	ESlopeStatus_MAX                         = 3,
};

// Enum DynamicNode.ETransitionZoneStatus_DN
// NumValues: 0x0003
enum class ETransitionZoneStatus_DN : uint8
{
	InZone                                   = 0,
	OutOfZone                                = 1,
	ETransitionZoneStatus_MAX                = 2,
};

// Enum DynamicNode.EDrawDebugTrace_DN
// NumValues: 0x0005
enum class EDrawDebugTrace_DN : uint8
{
	None                                     = 0,
	ForOneFrame                              = 1,
	ForDuration                              = 2,
	Persistent                               = 3,
	EDrawDebugTrace_MAX                      = 4,
};

// ScriptStruct DynamicNode.LegsPhysicalSurface_DN
// 0x0018 (0x0018 - 0x0000)
struct FLegsPhysicalSurface_DN final
{
public:
	bool                                          LeftLegPhysicalSurfaceDataIsValid;                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RightLegPhysicalSurfaceDataIsValid;                // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LeftLegPhysicalSurfaceDataIsDefaultMaterial;       // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RightLegPhysicalSurfaceDataIsDefaultMaterial;      // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPhysicalMaterial>       LeftLegPhysMaterial;                               // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPhysicalMaterial>       RightLegPhysMaterial;                              // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              LastLeftLegPhysicalSurface;                        // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              LastRightLegPhysicalSurface;                       // 0x0015(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegsPhysicalSurface_DN) == 0x000004, "Wrong alignment on FLegsPhysicalSurface_DN");
static_assert(sizeof(FLegsPhysicalSurface_DN) == 0x000018, "Wrong size on FLegsPhysicalSurface_DN");
static_assert(offsetof(FLegsPhysicalSurface_DN, LeftLegPhysicalSurfaceDataIsValid) == 0x000000, "Member 'FLegsPhysicalSurface_DN::LeftLegPhysicalSurfaceDataIsValid' has a wrong offset!");
static_assert(offsetof(FLegsPhysicalSurface_DN, RightLegPhysicalSurfaceDataIsValid) == 0x000001, "Member 'FLegsPhysicalSurface_DN::RightLegPhysicalSurfaceDataIsValid' has a wrong offset!");
static_assert(offsetof(FLegsPhysicalSurface_DN, LeftLegPhysicalSurfaceDataIsDefaultMaterial) == 0x000002, "Member 'FLegsPhysicalSurface_DN::LeftLegPhysicalSurfaceDataIsDefaultMaterial' has a wrong offset!");
static_assert(offsetof(FLegsPhysicalSurface_DN, RightLegPhysicalSurfaceDataIsDefaultMaterial) == 0x000003, "Member 'FLegsPhysicalSurface_DN::RightLegPhysicalSurfaceDataIsDefaultMaterial' has a wrong offset!");
static_assert(offsetof(FLegsPhysicalSurface_DN, LeftLegPhysMaterial) == 0x000004, "Member 'FLegsPhysicalSurface_DN::LeftLegPhysMaterial' has a wrong offset!");
static_assert(offsetof(FLegsPhysicalSurface_DN, RightLegPhysMaterial) == 0x00000C, "Member 'FLegsPhysicalSurface_DN::RightLegPhysMaterial' has a wrong offset!");
static_assert(offsetof(FLegsPhysicalSurface_DN, LastLeftLegPhysicalSurface) == 0x000014, "Member 'FLegsPhysicalSurface_DN::LastLeftLegPhysicalSurface' has a wrong offset!");
static_assert(offsetof(FLegsPhysicalSurface_DN, LastRightLegPhysicalSurface) == 0x000015, "Member 'FLegsPhysicalSurface_DN::LastRightLegPhysicalSurface' has a wrong offset!");

// ScriptStruct DynamicNode.UnEquipThingData_DN
// 0x0070 (0x0070 - 0x0000)
struct FUnEquipThingData_DN final
{
public:
	class AActor*                                 ThingActor;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NotifyToAction;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketUnequipName;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        OtherSceneComponent;                               // 0x0018(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             WorldSpaceTransform_NoScale;                       // 0x0020(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          EnablePhysicsOnFin;                                // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PhysCollisionProfileName;                          // 0x0054(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransformTime;                                     // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRateOverrideWhenTransform;                     // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0xC];                                       // 0x0064(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUnEquipThingData_DN) == 0x000010, "Wrong alignment on FUnEquipThingData_DN");
static_assert(sizeof(FUnEquipThingData_DN) == 0x000070, "Wrong size on FUnEquipThingData_DN");
static_assert(offsetof(FUnEquipThingData_DN, ThingActor) == 0x000000, "Member 'FUnEquipThingData_DN::ThingActor' has a wrong offset!");
static_assert(offsetof(FUnEquipThingData_DN, NotifyToAction) == 0x000008, "Member 'FUnEquipThingData_DN::NotifyToAction' has a wrong offset!");
static_assert(offsetof(FUnEquipThingData_DN, SocketUnequipName) == 0x000010, "Member 'FUnEquipThingData_DN::SocketUnequipName' has a wrong offset!");
static_assert(offsetof(FUnEquipThingData_DN, OtherSceneComponent) == 0x000018, "Member 'FUnEquipThingData_DN::OtherSceneComponent' has a wrong offset!");
static_assert(offsetof(FUnEquipThingData_DN, WorldSpaceTransform_NoScale) == 0x000020, "Member 'FUnEquipThingData_DN::WorldSpaceTransform_NoScale' has a wrong offset!");
static_assert(offsetof(FUnEquipThingData_DN, EnablePhysicsOnFin) == 0x000050, "Member 'FUnEquipThingData_DN::EnablePhysicsOnFin' has a wrong offset!");
static_assert(offsetof(FUnEquipThingData_DN, PhysCollisionProfileName) == 0x000054, "Member 'FUnEquipThingData_DN::PhysCollisionProfileName' has a wrong offset!");
static_assert(offsetof(FUnEquipThingData_DN, TransformTime) == 0x00005C, "Member 'FUnEquipThingData_DN::TransformTime' has a wrong offset!");
static_assert(offsetof(FUnEquipThingData_DN, PlayRateOverrideWhenTransform) == 0x000060, "Member 'FUnEquipThingData_DN::PlayRateOverrideWhenTransform' has a wrong offset!");

// ScriptStruct DynamicNode.AlignHandData_DN_Int
// 0x00B0 (0x00B0 - 0x0000)
struct alignas(0x10) FAlignHandData_DN_Int final
{
public:
	uint8                                         Pad_0[0xB0];                                       // 0x0000(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAlignHandData_DN_Int) == 0x000010, "Wrong alignment on FAlignHandData_DN_Int");
static_assert(sizeof(FAlignHandData_DN_Int) == 0x0000B0, "Wrong size on FAlignHandData_DN_Int");

// ScriptStruct DynamicNode.EquipThingData_DN
// 0x0070 (0x0070 - 0x0000)
struct FEquipThingData_DN final
{
public:
	class AActor*                                 ThingActor;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NotifyToAction;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HandSocketName;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GrabCollisionProfileName;                          // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransformTime;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRateOverrideWhenTransform;                     // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LocalTransform;                                    // 0x0030(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          UseInvertRotation;                                 // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseInputLocalInsteadSocketRotation;                // 0x0061(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0xE];                                       // 0x0062(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEquipThingData_DN) == 0x000010, "Wrong alignment on FEquipThingData_DN");
static_assert(sizeof(FEquipThingData_DN) == 0x000070, "Wrong size on FEquipThingData_DN");
static_assert(offsetof(FEquipThingData_DN, ThingActor) == 0x000000, "Member 'FEquipThingData_DN::ThingActor' has a wrong offset!");
static_assert(offsetof(FEquipThingData_DN, NotifyToAction) == 0x000008, "Member 'FEquipThingData_DN::NotifyToAction' has a wrong offset!");
static_assert(offsetof(FEquipThingData_DN, HandSocketName) == 0x000010, "Member 'FEquipThingData_DN::HandSocketName' has a wrong offset!");
static_assert(offsetof(FEquipThingData_DN, GrabCollisionProfileName) == 0x000018, "Member 'FEquipThingData_DN::GrabCollisionProfileName' has a wrong offset!");
static_assert(offsetof(FEquipThingData_DN, TransformTime) == 0x000020, "Member 'FEquipThingData_DN::TransformTime' has a wrong offset!");
static_assert(offsetof(FEquipThingData_DN, PlayRateOverrideWhenTransform) == 0x000024, "Member 'FEquipThingData_DN::PlayRateOverrideWhenTransform' has a wrong offset!");
static_assert(offsetof(FEquipThingData_DN, LocalTransform) == 0x000030, "Member 'FEquipThingData_DN::LocalTransform' has a wrong offset!");
static_assert(offsetof(FEquipThingData_DN, UseInvertRotation) == 0x000060, "Member 'FEquipThingData_DN::UseInvertRotation' has a wrong offset!");
static_assert(offsetof(FEquipThingData_DN, UseInputLocalInsteadSocketRotation) == 0x000061, "Member 'FEquipThingData_DN::UseInputLocalInsteadSocketRotation' has a wrong offset!");

// ScriptStruct DynamicNode.AdditionalTargetPointsData_DN
// 0x0040 (0x0040 - 0x0000)
struct FAdditionalTargetPointsData_DN final
{
public:
	bool                                          SetAddTargetPosition;                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             AddTargetPointData;                                // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAdditionalTargetPointsData_DN) == 0x000010, "Wrong alignment on FAdditionalTargetPointsData_DN");
static_assert(sizeof(FAdditionalTargetPointsData_DN) == 0x000040, "Wrong size on FAdditionalTargetPointsData_DN");
static_assert(offsetof(FAdditionalTargetPointsData_DN, SetAddTargetPosition) == 0x000000, "Member 'FAdditionalTargetPointsData_DN::SetAddTargetPosition' has a wrong offset!");
static_assert(offsetof(FAdditionalTargetPointsData_DN, AddTargetPointData) == 0x000010, "Member 'FAdditionalTargetPointsData_DN::AddTargetPointData' has a wrong offset!");

// ScriptStruct DynamicNode.HandsCCDIKAlignHandData_DN
// 0x0020 (0x0020 - 0x0000)
struct FHandsCCDIKAlignHandData_DN final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               AddHandRotation;                                   // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ClampHandDeltaAngle;                               // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxIterToFixClampPosition;                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AdditionalSocket;                                  // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHandsCCDIKAlignHandData_DN) == 0x000004, "Wrong alignment on FHandsCCDIKAlignHandData_DN");
static_assert(sizeof(FHandsCCDIKAlignHandData_DN) == 0x000020, "Wrong size on FHandsCCDIKAlignHandData_DN");
static_assert(offsetof(FHandsCCDIKAlignHandData_DN, Enabled) == 0x000000, "Member 'FHandsCCDIKAlignHandData_DN::Enabled' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKAlignHandData_DN, AddHandRotation) == 0x000004, "Member 'FHandsCCDIKAlignHandData_DN::AddHandRotation' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKAlignHandData_DN, ClampHandDeltaAngle) == 0x000010, "Member 'FHandsCCDIKAlignHandData_DN::ClampHandDeltaAngle' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKAlignHandData_DN, MaxIterToFixClampPosition) == 0x000014, "Member 'FHandsCCDIKAlignHandData_DN::MaxIterToFixClampPosition' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKAlignHandData_DN, AdditionalSocket) == 0x000018, "Member 'FHandsCCDIKAlignHandData_DN::AdditionalSocket' has a wrong offset!");

// ScriptStruct DynamicNode.AddIntermediatePointsData_DN
// 0x0040 (0x0040 - 0x0000)
struct FAddIntermediatePointsData_DN final
{
public:
	struct FTransform                             IntermediatePointData;                             // 0x0000(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Position;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAddIntermediatePointsData_DN) == 0x000010, "Wrong alignment on FAddIntermediatePointsData_DN");
static_assert(sizeof(FAddIntermediatePointsData_DN) == 0x000040, "Wrong size on FAddIntermediatePointsData_DN");
static_assert(offsetof(FAddIntermediatePointsData_DN, IntermediatePointData) == 0x000000, "Member 'FAddIntermediatePointsData_DN::IntermediatePointData' has a wrong offset!");
static_assert(offsetof(FAddIntermediatePointsData_DN, Position) == 0x000030, "Member 'FAddIntermediatePointsData_DN::Position' has a wrong offset!");

// ScriptStruct DynamicNode.AddIntermediatePoints_DN
// 0x0010 (0x0010 - 0x0000)
struct FAddIntermediatePoints_DN final
{
public:
	TArray<struct FAddIntermediatePointsData_DN>  AdditionalIntermediatePointsData;                  // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAddIntermediatePoints_DN) == 0x000008, "Wrong alignment on FAddIntermediatePoints_DN");
static_assert(sizeof(FAddIntermediatePoints_DN) == 0x000010, "Wrong size on FAddIntermediatePoints_DN");
static_assert(offsetof(FAddIntermediatePoints_DN, AdditionalIntermediatePointsData) == 0x000000, "Member 'FAddIntermediatePoints_DN::AdditionalIntermediatePointsData' has a wrong offset!");

// ScriptStruct DynamicNode.HandsCCDIKMotilityData_DN
// 0x001C (0x001C - 0x0000)
struct FHandsCCDIKMotilityData_DN final
{
public:
	float                                         MotilityPerJoint;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MotilityUpperarm;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MotilityLowerarm;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MotilityHand;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MotilityIndexFinger;                               // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MotilityPerJointBackMove;                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MotilityHandBackMove;                              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHandsCCDIKMotilityData_DN) == 0x000004, "Wrong alignment on FHandsCCDIKMotilityData_DN");
static_assert(sizeof(FHandsCCDIKMotilityData_DN) == 0x00001C, "Wrong size on FHandsCCDIKMotilityData_DN");
static_assert(offsetof(FHandsCCDIKMotilityData_DN, MotilityPerJoint) == 0x000000, "Member 'FHandsCCDIKMotilityData_DN::MotilityPerJoint' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKMotilityData_DN, MotilityUpperarm) == 0x000004, "Member 'FHandsCCDIKMotilityData_DN::MotilityUpperarm' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKMotilityData_DN, MotilityLowerarm) == 0x000008, "Member 'FHandsCCDIKMotilityData_DN::MotilityLowerarm' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKMotilityData_DN, MotilityHand) == 0x00000C, "Member 'FHandsCCDIKMotilityData_DN::MotilityHand' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKMotilityData_DN, MotilityIndexFinger) == 0x000010, "Member 'FHandsCCDIKMotilityData_DN::MotilityIndexFinger' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKMotilityData_DN, MotilityPerJointBackMove) == 0x000014, "Member 'FHandsCCDIKMotilityData_DN::MotilityPerJointBackMove' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKMotilityData_DN, MotilityHandBackMove) == 0x000018, "Member 'FHandsCCDIKMotilityData_DN::MotilityHandBackMove' has a wrong offset!");

// ScriptStruct DynamicNode.HandsCCDIKSpecificData_DN
// 0x0050 (0x0050 - 0x0000)
struct FHandsCCDIKSpecificData_DN final
{
public:
	float                                         MaxHandLength;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                UpperarmSolverHandMoveDir_CS;                      // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                UpperarmSolverRotationAxis_CS;                     // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperarmSolverRotationAngle;                       // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperarmSolverRotationMulti_Negation;              // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                UpperarmSolverForwardMoveDir;                      // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperarmSolverForwardMoveMulti;                    // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperarmSolverForwardMoveMulti_Negation;           // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShoulderStretchCoef;                               // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShoulderStretchSideMoveDivider;                    // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperArmRotationLimit;                             // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IndexFingerZOffset;                                // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IndexFingerBackOffset;                             // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IndexFingerBackBoneIndex;                          // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHandsCCDIKSpecificData_DN) == 0x000004, "Wrong alignment on FHandsCCDIKSpecificData_DN");
static_assert(sizeof(FHandsCCDIKSpecificData_DN) == 0x000050, "Wrong size on FHandsCCDIKSpecificData_DN");
static_assert(offsetof(FHandsCCDIKSpecificData_DN, MaxHandLength) == 0x000000, "Member 'FHandsCCDIKSpecificData_DN::MaxHandLength' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKSpecificData_DN, UpperarmSolverHandMoveDir_CS) == 0x000004, "Member 'FHandsCCDIKSpecificData_DN::UpperarmSolverHandMoveDir_CS' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKSpecificData_DN, UpperarmSolverRotationAxis_CS) == 0x000010, "Member 'FHandsCCDIKSpecificData_DN::UpperarmSolverRotationAxis_CS' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKSpecificData_DN, UpperarmSolverRotationAngle) == 0x00001C, "Member 'FHandsCCDIKSpecificData_DN::UpperarmSolverRotationAngle' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKSpecificData_DN, UpperarmSolverRotationMulti_Negation) == 0x000020, "Member 'FHandsCCDIKSpecificData_DN::UpperarmSolverRotationMulti_Negation' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKSpecificData_DN, UpperarmSolverForwardMoveDir) == 0x000024, "Member 'FHandsCCDIKSpecificData_DN::UpperarmSolverForwardMoveDir' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKSpecificData_DN, UpperarmSolverForwardMoveMulti) == 0x000030, "Member 'FHandsCCDIKSpecificData_DN::UpperarmSolverForwardMoveMulti' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKSpecificData_DN, UpperarmSolverForwardMoveMulti_Negation) == 0x000034, "Member 'FHandsCCDIKSpecificData_DN::UpperarmSolverForwardMoveMulti_Negation' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKSpecificData_DN, ShoulderStretchCoef) == 0x000038, "Member 'FHandsCCDIKSpecificData_DN::ShoulderStretchCoef' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKSpecificData_DN, ShoulderStretchSideMoveDivider) == 0x00003C, "Member 'FHandsCCDIKSpecificData_DN::ShoulderStretchSideMoveDivider' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKSpecificData_DN, UpperArmRotationLimit) == 0x000040, "Member 'FHandsCCDIKSpecificData_DN::UpperArmRotationLimit' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKSpecificData_DN, IndexFingerZOffset) == 0x000044, "Member 'FHandsCCDIKSpecificData_DN::IndexFingerZOffset' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKSpecificData_DN, IndexFingerBackOffset) == 0x000048, "Member 'FHandsCCDIKSpecificData_DN::IndexFingerBackOffset' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKSpecificData_DN, IndexFingerBackBoneIndex) == 0x00004C, "Member 'FHandsCCDIKSpecificData_DN::IndexFingerBackBoneIndex' has a wrong offset!");

// ScriptStruct DynamicNode.HandsCCDIKData_DN
// 0x00B0 (0x00B0 - 0x0000)
struct FHandsCCDIKData_DN final
{
public:
	class FName                                   UpperarmBoneName;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HandBoneName;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IndexFingerBoneNameOptional;                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumBonesInIndexFingerOptional;                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GrabSocketNameOptional;                            // 0x001C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PressSocketNameOptional;                           // 0x0024(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Performance;                                       // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSoftTransition;                                 // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SoftTransitionPower;                               // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoftTransitionDecCoeffPropsActor;                  // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoftTransitionDecCoeffSpeed;                       // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InverseAlgorithm;                                  // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InverseAlgorithmBackMove;                          // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHandsCCDIKMotilityData_DN             MotilityData;                                      // 0x0044(0x001C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FHandsCCDIKSpecificData_DN             HandsCCDIKSpecificData;                            // 0x0060(0x0050)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHandsCCDIKData_DN) == 0x000004, "Wrong alignment on FHandsCCDIKData_DN");
static_assert(sizeof(FHandsCCDIKData_DN) == 0x0000B0, "Wrong size on FHandsCCDIKData_DN");
static_assert(offsetof(FHandsCCDIKData_DN, UpperarmBoneName) == 0x000000, "Member 'FHandsCCDIKData_DN::UpperarmBoneName' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKData_DN, HandBoneName) == 0x000008, "Member 'FHandsCCDIKData_DN::HandBoneName' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKData_DN, IndexFingerBoneNameOptional) == 0x000010, "Member 'FHandsCCDIKData_DN::IndexFingerBoneNameOptional' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKData_DN, NumBonesInIndexFingerOptional) == 0x000018, "Member 'FHandsCCDIKData_DN::NumBonesInIndexFingerOptional' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKData_DN, GrabSocketNameOptional) == 0x00001C, "Member 'FHandsCCDIKData_DN::GrabSocketNameOptional' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKData_DN, PressSocketNameOptional) == 0x000024, "Member 'FHandsCCDIKData_DN::PressSocketNameOptional' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKData_DN, Performance) == 0x00002C, "Member 'FHandsCCDIKData_DN::Performance' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKData_DN, UseSoftTransition) == 0x000030, "Member 'FHandsCCDIKData_DN::UseSoftTransition' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKData_DN, SoftTransitionPower) == 0x000034, "Member 'FHandsCCDIKData_DN::SoftTransitionPower' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKData_DN, SoftTransitionDecCoeffPropsActor) == 0x000038, "Member 'FHandsCCDIKData_DN::SoftTransitionDecCoeffPropsActor' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKData_DN, SoftTransitionDecCoeffSpeed) == 0x00003C, "Member 'FHandsCCDIKData_DN::SoftTransitionDecCoeffSpeed' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKData_DN, InverseAlgorithm) == 0x000040, "Member 'FHandsCCDIKData_DN::InverseAlgorithm' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKData_DN, InverseAlgorithmBackMove) == 0x000041, "Member 'FHandsCCDIKData_DN::InverseAlgorithmBackMove' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKData_DN, MotilityData) == 0x000044, "Member 'FHandsCCDIKData_DN::MotilityData' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKData_DN, HandsCCDIKSpecificData) == 0x000060, "Member 'FHandsCCDIKData_DN::HandsCCDIKSpecificData' has a wrong offset!");

// ScriptStruct DynamicNode.IntermediatePointsData_DN
// 0x00C0 (0x00C0 - 0x0000)
struct FIntermediatePointsData_DN final
{
public:
	bool                                          SetPosition;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             IntermediatePointData;                             // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x60];                                      // 0x0040(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Position;                                          // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x1C];                                      // 0x00A4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIntermediatePointsData_DN) == 0x000010, "Wrong alignment on FIntermediatePointsData_DN");
static_assert(sizeof(FIntermediatePointsData_DN) == 0x0000C0, "Wrong size on FIntermediatePointsData_DN");
static_assert(offsetof(FIntermediatePointsData_DN, SetPosition) == 0x000000, "Member 'FIntermediatePointsData_DN::SetPosition' has a wrong offset!");
static_assert(offsetof(FIntermediatePointsData_DN, IntermediatePointData) == 0x000010, "Member 'FIntermediatePointsData_DN::IntermediatePointData' has a wrong offset!");
static_assert(offsetof(FIntermediatePointsData_DN, Position) == 0x0000A0, "Member 'FIntermediatePointsData_DN::Position' has a wrong offset!");

// ScriptStruct DynamicNode.HandsCCDIKTargetHandFollowDataAInfo_DN
// 0x0058 (0x0058 - 0x0000)
struct FHandsCCDIKTargetHandFollowDataAInfo_DN final
{
public:
	bool                                          AlignEnabled;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PropagatesAlignMeshForAllSockets;                  // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         AlignComponent;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AddHandRotation;                                   // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          UseSpecificTransformForReverseMode;                // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HandTranslationReverseMode;                        // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               HandRotationReverseMode;                           // 0x002C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClampHandDeltaAngle;                               // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxIterToFixClampPosition;                         // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHandsCCDIKTargetHandFollowDataAInfo_DN) == 0x000008, "Wrong alignment on FHandsCCDIKTargetHandFollowDataAInfo_DN");
static_assert(sizeof(FHandsCCDIKTargetHandFollowDataAInfo_DN) == 0x000058, "Wrong size on FHandsCCDIKTargetHandFollowDataAInfo_DN");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataAInfo_DN, AlignEnabled) == 0x000000, "Member 'FHandsCCDIKTargetHandFollowDataAInfo_DN::AlignEnabled' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataAInfo_DN, PropagatesAlignMeshForAllSockets) == 0x000001, "Member 'FHandsCCDIKTargetHandFollowDataAInfo_DN::PropagatesAlignMeshForAllSockets' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataAInfo_DN, AlignComponent) == 0x000008, "Member 'FHandsCCDIKTargetHandFollowDataAInfo_DN::AlignComponent' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataAInfo_DN, AddHandRotation) == 0x000010, "Member 'FHandsCCDIKTargetHandFollowDataAInfo_DN::AddHandRotation' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataAInfo_DN, UseSpecificTransformForReverseMode) == 0x00001C, "Member 'FHandsCCDIKTargetHandFollowDataAInfo_DN::UseSpecificTransformForReverseMode' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataAInfo_DN, HandTranslationReverseMode) == 0x000020, "Member 'FHandsCCDIKTargetHandFollowDataAInfo_DN::HandTranslationReverseMode' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataAInfo_DN, HandRotationReverseMode) == 0x00002C, "Member 'FHandsCCDIKTargetHandFollowDataAInfo_DN::HandRotationReverseMode' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataAInfo_DN, ClampHandDeltaAngle) == 0x000050, "Member 'FHandsCCDIKTargetHandFollowDataAInfo_DN::ClampHandDeltaAngle' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataAInfo_DN, MaxIterToFixClampPosition) == 0x000054, "Member 'FHandsCCDIKTargetHandFollowDataAInfo_DN::MaxIterToFixClampPosition' has a wrong offset!");

// ScriptStruct DynamicNode.HandsCCDIKSpecificDataOverride_DN
// 0x0058 (0x0058 - 0x0000)
struct FHandsCCDIKSpecificDataOverride_DN final
{
public:
	class UAnimationAsset*                        AnimationAsset;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHandsCCDIKSpecificData_DN             HandsCCDIKSpecificData;                            // 0x0008(0x0050)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHandsCCDIKSpecificDataOverride_DN) == 0x000008, "Wrong alignment on FHandsCCDIKSpecificDataOverride_DN");
static_assert(sizeof(FHandsCCDIKSpecificDataOverride_DN) == 0x000058, "Wrong size on FHandsCCDIKSpecificDataOverride_DN");
static_assert(offsetof(FHandsCCDIKSpecificDataOverride_DN, AnimationAsset) == 0x000000, "Member 'FHandsCCDIKSpecificDataOverride_DN::AnimationAsset' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKSpecificDataOverride_DN, HandsCCDIKSpecificData) == 0x000008, "Member 'FHandsCCDIKSpecificDataOverride_DN::HandsCCDIKSpecificData' has a wrong offset!");

// ScriptStruct DynamicNode.HandsCCDIKTargetHandFollowDataH_DN
// 0x00C0 (0x00C0 - 0x0000)
struct alignas(0x08) FHandsCCDIKTargetHandFollowDataH_DN final
{
public:
	class FName                                   TargetSocketName;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          AlignEnabled;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x17];                                      // 0x0011(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UHandleComponent_DN>     AlignComponent;                                    // 0x0028(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PropagatesAlignMeshForAllSockets;                  // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AlignRotationPower;                                // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlignRotationPowerReverseMode;                     // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseComplexAngleCalculation;                        // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ComplexAngleCalculationBorder;                     // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAutoCalculateAngle_DN                        AutoCalculateAngle;                                // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoCalculateAngleOnlyInitial;                     // 0x0045(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAutoCalculateAngle_DN                        AutoCalculateAngleReverseMode;                     // 0x0046(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoCalculateAngleOnlyInitialReverseMode;          // 0x0047(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x6C];                                      // 0x0048(0x006C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClampHandDeltaAngle;                               // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxIterToFixClampPosition;                         // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHandsCCDIKTargetHandFollowDataH_DN) == 0x000008, "Wrong alignment on FHandsCCDIKTargetHandFollowDataH_DN");
static_assert(sizeof(FHandsCCDIKTargetHandFollowDataH_DN) == 0x0000C0, "Wrong size on FHandsCCDIKTargetHandFollowDataH_DN");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataH_DN, TargetSocketName) == 0x000000, "Member 'FHandsCCDIKTargetHandFollowDataH_DN::TargetSocketName' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataH_DN, AlignEnabled) == 0x000010, "Member 'FHandsCCDIKTargetHandFollowDataH_DN::AlignEnabled' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataH_DN, AlignComponent) == 0x000028, "Member 'FHandsCCDIKTargetHandFollowDataH_DN::AlignComponent' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataH_DN, PropagatesAlignMeshForAllSockets) == 0x000030, "Member 'FHandsCCDIKTargetHandFollowDataH_DN::PropagatesAlignMeshForAllSockets' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataH_DN, AlignRotationPower) == 0x000034, "Member 'FHandsCCDIKTargetHandFollowDataH_DN::AlignRotationPower' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataH_DN, AlignRotationPowerReverseMode) == 0x000038, "Member 'FHandsCCDIKTargetHandFollowDataH_DN::AlignRotationPowerReverseMode' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataH_DN, UseComplexAngleCalculation) == 0x00003C, "Member 'FHandsCCDIKTargetHandFollowDataH_DN::UseComplexAngleCalculation' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataH_DN, ComplexAngleCalculationBorder) == 0x000040, "Member 'FHandsCCDIKTargetHandFollowDataH_DN::ComplexAngleCalculationBorder' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataH_DN, AutoCalculateAngle) == 0x000044, "Member 'FHandsCCDIKTargetHandFollowDataH_DN::AutoCalculateAngle' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataH_DN, AutoCalculateAngleOnlyInitial) == 0x000045, "Member 'FHandsCCDIKTargetHandFollowDataH_DN::AutoCalculateAngleOnlyInitial' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataH_DN, AutoCalculateAngleReverseMode) == 0x000046, "Member 'FHandsCCDIKTargetHandFollowDataH_DN::AutoCalculateAngleReverseMode' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataH_DN, AutoCalculateAngleOnlyInitialReverseMode) == 0x000047, "Member 'FHandsCCDIKTargetHandFollowDataH_DN::AutoCalculateAngleOnlyInitialReverseMode' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataH_DN, ClampHandDeltaAngle) == 0x0000B4, "Member 'FHandsCCDIKTargetHandFollowDataH_DN::ClampHandDeltaAngle' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowDataH_DN, MaxIterToFixClampPosition) == 0x0000B8, "Member 'FHandsCCDIKTargetHandFollowDataH_DN::MaxIterToFixClampPosition' has a wrong offset!");

// ScriptStruct DynamicNode.HandsIKForwardMoving_DN
// 0x0028 (0x0028 - 0x0000)
struct FHandsIKForwardMoving_DN final
{
public:
	struct FVector                                ForwardMovingHandVector_CS;                        // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardMovingHandCoeff;                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardMovingHandClampMax;                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BackwardMovingHandVector_CS;                       // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackwardMovingHandCoeff;                           // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackwardMovingHandClampMax;                        // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHandsIKForwardMoving_DN) == 0x000004, "Wrong alignment on FHandsIKForwardMoving_DN");
static_assert(sizeof(FHandsIKForwardMoving_DN) == 0x000028, "Wrong size on FHandsIKForwardMoving_DN");
static_assert(offsetof(FHandsIKForwardMoving_DN, ForwardMovingHandVector_CS) == 0x000000, "Member 'FHandsIKForwardMoving_DN::ForwardMovingHandVector_CS' has a wrong offset!");
static_assert(offsetof(FHandsIKForwardMoving_DN, ForwardMovingHandCoeff) == 0x00000C, "Member 'FHandsIKForwardMoving_DN::ForwardMovingHandCoeff' has a wrong offset!");
static_assert(offsetof(FHandsIKForwardMoving_DN, ForwardMovingHandClampMax) == 0x000010, "Member 'FHandsIKForwardMoving_DN::ForwardMovingHandClampMax' has a wrong offset!");
static_assert(offsetof(FHandsIKForwardMoving_DN, BackwardMovingHandVector_CS) == 0x000014, "Member 'FHandsIKForwardMoving_DN::BackwardMovingHandVector_CS' has a wrong offset!");
static_assert(offsetof(FHandsIKForwardMoving_DN, BackwardMovingHandCoeff) == 0x000020, "Member 'FHandsIKForwardMoving_DN::BackwardMovingHandCoeff' has a wrong offset!");
static_assert(offsetof(FHandsIKForwardMoving_DN, BackwardMovingHandClampMax) == 0x000024, "Member 'FHandsIKForwardMoving_DN::BackwardMovingHandClampMax' has a wrong offset!");

// ScriptStruct DynamicNode.HandsIKOrientation_DN
// 0x004C (0x004C - 0x0000)
struct FHandsIKOrientation_DN final
{
public:
	bool                                          FreeHandRotation;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HandRotationPower;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SolveUpperarmRotationAxis_CS;                      // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SolveUpperarmPower;                                // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SolveUpperarmNegation;                             // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                UpperArmAddRotationHandVector_CS;                  // 0x001C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                UpperArmAddRotationAxis_CS;                        // 0x0028(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperArmAddRotationAngle;                          // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperArmAddRotationClampMax;                       // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               InitOffsetRotationUpperArm_CS;                     // 0x003C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          UseInitRotationUpperArmBeforeSolve;                // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHandsIKOrientation_DN) == 0x000004, "Wrong alignment on FHandsIKOrientation_DN");
static_assert(sizeof(FHandsIKOrientation_DN) == 0x00004C, "Wrong size on FHandsIKOrientation_DN");
static_assert(offsetof(FHandsIKOrientation_DN, FreeHandRotation) == 0x000000, "Member 'FHandsIKOrientation_DN::FreeHandRotation' has a wrong offset!");
static_assert(offsetof(FHandsIKOrientation_DN, HandRotationPower) == 0x000004, "Member 'FHandsIKOrientation_DN::HandRotationPower' has a wrong offset!");
static_assert(offsetof(FHandsIKOrientation_DN, SolveUpperarmRotationAxis_CS) == 0x000008, "Member 'FHandsIKOrientation_DN::SolveUpperarmRotationAxis_CS' has a wrong offset!");
static_assert(offsetof(FHandsIKOrientation_DN, SolveUpperarmPower) == 0x000014, "Member 'FHandsIKOrientation_DN::SolveUpperarmPower' has a wrong offset!");
static_assert(offsetof(FHandsIKOrientation_DN, SolveUpperarmNegation) == 0x000018, "Member 'FHandsIKOrientation_DN::SolveUpperarmNegation' has a wrong offset!");
static_assert(offsetof(FHandsIKOrientation_DN, UpperArmAddRotationHandVector_CS) == 0x00001C, "Member 'FHandsIKOrientation_DN::UpperArmAddRotationHandVector_CS' has a wrong offset!");
static_assert(offsetof(FHandsIKOrientation_DN, UpperArmAddRotationAxis_CS) == 0x000028, "Member 'FHandsIKOrientation_DN::UpperArmAddRotationAxis_CS' has a wrong offset!");
static_assert(offsetof(FHandsIKOrientation_DN, UpperArmAddRotationAngle) == 0x000034, "Member 'FHandsIKOrientation_DN::UpperArmAddRotationAngle' has a wrong offset!");
static_assert(offsetof(FHandsIKOrientation_DN, UpperArmAddRotationClampMax) == 0x000038, "Member 'FHandsIKOrientation_DN::UpperArmAddRotationClampMax' has a wrong offset!");
static_assert(offsetof(FHandsIKOrientation_DN, InitOffsetRotationUpperArm_CS) == 0x00003C, "Member 'FHandsIKOrientation_DN::InitOffsetRotationUpperArm_CS' has a wrong offset!");
static_assert(offsetof(FHandsIKOrientation_DN, UseInitRotationUpperArmBeforeSolve) == 0x000048, "Member 'FHandsIKOrientation_DN::UseInitRotationUpperArmBeforeSolve' has a wrong offset!");

// ScriptStruct DynamicNode.HandsIKSpecificData_DN
// 0x00A4 (0x00A4 - 0x0000)
struct FHandsIKSpecificData_DN final
{
public:
	struct FVector                                BodyForwardVector_CS;                              // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               BodyForwardRotator_CS;                             // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                BodyAddForwardTranslation;                         // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampUpDownMove;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampSideMove;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandMovingIntensity;                               // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHandsIKForwardMoving_DN               SpecificDataForwardMoving;                         // 0x0030(0x0028)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FHandsIKOrientation_DN                 SpecificDataRotation;                              // 0x0058(0x004C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHandsIKSpecificData_DN) == 0x000004, "Wrong alignment on FHandsIKSpecificData_DN");
static_assert(sizeof(FHandsIKSpecificData_DN) == 0x0000A4, "Wrong size on FHandsIKSpecificData_DN");
static_assert(offsetof(FHandsIKSpecificData_DN, BodyForwardVector_CS) == 0x000000, "Member 'FHandsIKSpecificData_DN::BodyForwardVector_CS' has a wrong offset!");
static_assert(offsetof(FHandsIKSpecificData_DN, BodyForwardRotator_CS) == 0x00000C, "Member 'FHandsIKSpecificData_DN::BodyForwardRotator_CS' has a wrong offset!");
static_assert(offsetof(FHandsIKSpecificData_DN, BodyAddForwardTranslation) == 0x000018, "Member 'FHandsIKSpecificData_DN::BodyAddForwardTranslation' has a wrong offset!");
static_assert(offsetof(FHandsIKSpecificData_DN, ClampUpDownMove) == 0x000024, "Member 'FHandsIKSpecificData_DN::ClampUpDownMove' has a wrong offset!");
static_assert(offsetof(FHandsIKSpecificData_DN, ClampSideMove) == 0x000028, "Member 'FHandsIKSpecificData_DN::ClampSideMove' has a wrong offset!");
static_assert(offsetof(FHandsIKSpecificData_DN, HandMovingIntensity) == 0x00002C, "Member 'FHandsIKSpecificData_DN::HandMovingIntensity' has a wrong offset!");
static_assert(offsetof(FHandsIKSpecificData_DN, SpecificDataForwardMoving) == 0x000030, "Member 'FHandsIKSpecificData_DN::SpecificDataForwardMoving' has a wrong offset!");
static_assert(offsetof(FHandsIKSpecificData_DN, SpecificDataRotation) == 0x000058, "Member 'FHandsIKSpecificData_DN::SpecificDataRotation' has a wrong offset!");

// ScriptStruct DynamicNode.HandsIKData_DN
// 0x00DC (0x00DC - 0x0000)
struct FHandsIKData_DN final
{
public:
	struct FHandsIKSpecificData_DN                HandsIKSpecificData;                               // 0x0000(0x00A4)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   HandBoneName;                                      // 0x00A4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpineBoneName;                                     // 0x00AC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HandForwardVector;                                 // 0x00B4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnchorSize;                                        // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionTimeTranslation;                         // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionTimeRotation;                            // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawDebug;                                         // 0x00CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               InitialDeltaHandRotation;                          // 0x00D0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHandsIKData_DN) == 0x000004, "Wrong alignment on FHandsIKData_DN");
static_assert(sizeof(FHandsIKData_DN) == 0x0000DC, "Wrong size on FHandsIKData_DN");
static_assert(offsetof(FHandsIKData_DN, HandsIKSpecificData) == 0x000000, "Member 'FHandsIKData_DN::HandsIKSpecificData' has a wrong offset!");
static_assert(offsetof(FHandsIKData_DN, HandBoneName) == 0x0000A4, "Member 'FHandsIKData_DN::HandBoneName' has a wrong offset!");
static_assert(offsetof(FHandsIKData_DN, SpineBoneName) == 0x0000AC, "Member 'FHandsIKData_DN::SpineBoneName' has a wrong offset!");
static_assert(offsetof(FHandsIKData_DN, HandForwardVector) == 0x0000B4, "Member 'FHandsIKData_DN::HandForwardVector' has a wrong offset!");
static_assert(offsetof(FHandsIKData_DN, AnchorSize) == 0x0000C0, "Member 'FHandsIKData_DN::AnchorSize' has a wrong offset!");
static_assert(offsetof(FHandsIKData_DN, TransitionTimeTranslation) == 0x0000C4, "Member 'FHandsIKData_DN::TransitionTimeTranslation' has a wrong offset!");
static_assert(offsetof(FHandsIKData_DN, TransitionTimeRotation) == 0x0000C8, "Member 'FHandsIKData_DN::TransitionTimeRotation' has a wrong offset!");
static_assert(offsetof(FHandsIKData_DN, DrawDebug) == 0x0000CC, "Member 'FHandsIKData_DN::DrawDebug' has a wrong offset!");
static_assert(offsetof(FHandsIKData_DN, InitialDeltaHandRotation) == 0x0000D0, "Member 'FHandsIKData_DN::InitialDeltaHandRotation' has a wrong offset!");

// ScriptStruct DynamicNode.HandsCCDIKSpecificFinalRotationReverse_DN
// 0x001C (0x001C - 0x0000)
struct FHandsCCDIKSpecificFinalRotationReverse_DN final
{
public:
	bool                                          UseSpecificFinalRotationReverseMode;               // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HandFinalTranslationReverseMode;                   // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               HandFinalRotationReverseMode;                      // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHandsCCDIKSpecificFinalRotationReverse_DN) == 0x000004, "Wrong alignment on FHandsCCDIKSpecificFinalRotationReverse_DN");
static_assert(sizeof(FHandsCCDIKSpecificFinalRotationReverse_DN) == 0x00001C, "Wrong size on FHandsCCDIKSpecificFinalRotationReverse_DN");
static_assert(offsetof(FHandsCCDIKSpecificFinalRotationReverse_DN, UseSpecificFinalRotationReverseMode) == 0x000000, "Member 'FHandsCCDIKSpecificFinalRotationReverse_DN::UseSpecificFinalRotationReverseMode' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKSpecificFinalRotationReverse_DN, HandFinalTranslationReverseMode) == 0x000004, "Member 'FHandsCCDIKSpecificFinalRotationReverse_DN::HandFinalTranslationReverseMode' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKSpecificFinalRotationReverse_DN, HandFinalRotationReverseMode) == 0x000010, "Member 'FHandsCCDIKSpecificFinalRotationReverse_DN::HandFinalRotationReverseMode' has a wrong offset!");

// ScriptStruct DynamicNode.HandsCCDIKSpecificTransformForReverse_DN
// 0x0038 (0x0038 - 0x0000)
struct FHandsCCDIKSpecificTransformForReverse_DN final
{
public:
	bool                                          UseSpecificTransformForReverseMode;                // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HandTranslationReverseMode;                        // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               HandRotationReverseMode;                           // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FHandsCCDIKSpecificFinalRotationReverse_DN SpecificFinalRotationReverseMode;                  // 0x001C(0x001C)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHandsCCDIKSpecificTransformForReverse_DN) == 0x000004, "Wrong alignment on FHandsCCDIKSpecificTransformForReverse_DN");
static_assert(sizeof(FHandsCCDIKSpecificTransformForReverse_DN) == 0x000038, "Wrong size on FHandsCCDIKSpecificTransformForReverse_DN");
static_assert(offsetof(FHandsCCDIKSpecificTransformForReverse_DN, UseSpecificTransformForReverseMode) == 0x000000, "Member 'FHandsCCDIKSpecificTransformForReverse_DN::UseSpecificTransformForReverseMode' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKSpecificTransformForReverse_DN, HandTranslationReverseMode) == 0x000004, "Member 'FHandsCCDIKSpecificTransformForReverse_DN::HandTranslationReverseMode' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKSpecificTransformForReverse_DN, HandRotationReverseMode) == 0x000010, "Member 'FHandsCCDIKSpecificTransformForReverse_DN::HandRotationReverseMode' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKSpecificTransformForReverse_DN, SpecificFinalRotationReverseMode) == 0x00001C, "Member 'FHandsCCDIKSpecificTransformForReverse_DN::SpecificFinalRotationReverseMode' has a wrong offset!");

// ScriptStruct DynamicNode.HandsCCDIKSpecificFinalRotation_DN
// 0x001C (0x001C - 0x0000)
struct FHandsCCDIKSpecificFinalRotation_DN final
{
public:
	bool                                          UseSpecificFinalRotation;                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HandFinalTranslation;                              // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               HandFinalRotation;                                 // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHandsCCDIKSpecificFinalRotation_DN) == 0x000004, "Wrong alignment on FHandsCCDIKSpecificFinalRotation_DN");
static_assert(sizeof(FHandsCCDIKSpecificFinalRotation_DN) == 0x00001C, "Wrong size on FHandsCCDIKSpecificFinalRotation_DN");
static_assert(offsetof(FHandsCCDIKSpecificFinalRotation_DN, UseSpecificFinalRotation) == 0x000000, "Member 'FHandsCCDIKSpecificFinalRotation_DN::UseSpecificFinalRotation' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKSpecificFinalRotation_DN, HandFinalTranslation) == 0x000004, "Member 'FHandsCCDIKSpecificFinalRotation_DN::HandFinalTranslation' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKSpecificFinalRotation_DN, HandFinalRotation) == 0x000010, "Member 'FHandsCCDIKSpecificFinalRotation_DN::HandFinalRotation' has a wrong offset!");

// ScriptStruct DynamicNode.HandsCCDIKTargetHandFollowData_DN
// 0x0030 (0x0030 - 0x0000)
struct FHandsCCDIKTargetHandFollowData_DN final
{
public:
	class FName                                   TargetSocketName;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlignEnabled;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         AlignComponent;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AddHandRotation;                                   // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ClampHandDeltaAngle;                               // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxIterToFixClampPosition;                         // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHandsCCDIKTargetHandFollowData_DN) == 0x000008, "Wrong alignment on FHandsCCDIKTargetHandFollowData_DN");
static_assert(sizeof(FHandsCCDIKTargetHandFollowData_DN) == 0x000030, "Wrong size on FHandsCCDIKTargetHandFollowData_DN");
static_assert(offsetof(FHandsCCDIKTargetHandFollowData_DN, TargetSocketName) == 0x000000, "Member 'FHandsCCDIKTargetHandFollowData_DN::TargetSocketName' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowData_DN, AlignEnabled) == 0x000008, "Member 'FHandsCCDIKTargetHandFollowData_DN::AlignEnabled' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowData_DN, AlignComponent) == 0x000010, "Member 'FHandsCCDIKTargetHandFollowData_DN::AlignComponent' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowData_DN, AddHandRotation) == 0x000018, "Member 'FHandsCCDIKTargetHandFollowData_DN::AddHandRotation' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowData_DN, ClampHandDeltaAngle) == 0x000024, "Member 'FHandsCCDIKTargetHandFollowData_DN::ClampHandDeltaAngle' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKTargetHandFollowData_DN, MaxIterToFixClampPosition) == 0x000028, "Member 'FHandsCCDIKTargetHandFollowData_DN::MaxIterToFixClampPosition' has a wrong offset!");

// ScriptStruct DynamicNode.HandsIKSpecificDataOverride_DN
// 0x00B0 (0x00B0 - 0x0000)
struct FHandsIKSpecificDataOverride_DN final
{
public:
	class UAnimationAsset*                        AnimationAsset;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHandsIKSpecificData_DN                HandsIKSpecificData;                               // 0x0008(0x00A4)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHandsIKSpecificDataOverride_DN) == 0x000008, "Wrong alignment on FHandsIKSpecificDataOverride_DN");
static_assert(sizeof(FHandsIKSpecificDataOverride_DN) == 0x0000B0, "Wrong size on FHandsIKSpecificDataOverride_DN");
static_assert(offsetof(FHandsIKSpecificDataOverride_DN, AnimationAsset) == 0x000000, "Member 'FHandsIKSpecificDataOverride_DN::AnimationAsset' has a wrong offset!");
static_assert(offsetof(FHandsIKSpecificDataOverride_DN, HandsIKSpecificData) == 0x000008, "Member 'FHandsIKSpecificDataOverride_DN::HandsIKSpecificData' has a wrong offset!");

// ScriptStruct DynamicNode.HandsCCDIKHandleDataH_DN
// 0x001C (0x001C - 0x0000)
struct FHandsCCDIKHandleDataH_DN final
{
public:
	bool                                          UseHandleType;                                     // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HandTranslation;                                   // 0x0004(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               HandRotation;                                      // 0x0010(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHandsCCDIKHandleDataH_DN) == 0x000004, "Wrong alignment on FHandsCCDIKHandleDataH_DN");
static_assert(sizeof(FHandsCCDIKHandleDataH_DN) == 0x00001C, "Wrong size on FHandsCCDIKHandleDataH_DN");
static_assert(offsetof(FHandsCCDIKHandleDataH_DN, UseHandleType) == 0x000000, "Member 'FHandsCCDIKHandleDataH_DN::UseHandleType' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKHandleDataH_DN, HandTranslation) == 0x000004, "Member 'FHandsCCDIKHandleDataH_DN::HandTranslation' has a wrong offset!");
static_assert(offsetof(FHandsCCDIKHandleDataH_DN, HandRotation) == 0x000010, "Member 'FHandsCCDIKHandleDataH_DN::HandRotation' has a wrong offset!");

// ScriptStruct DynamicNode.GroundDeltaLegsOverride_DN
// 0x0018 (0x0018 - 0x0000)
struct FGroundDeltaLegsOverride_DN final
{
public:
	float                                         InterpolationSpeed;                                // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationAsset*                        AnimationAsset;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundDeltaOverride;                               // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGroundDeltaLegsOverride_DN) == 0x000008, "Wrong alignment on FGroundDeltaLegsOverride_DN");
static_assert(sizeof(FGroundDeltaLegsOverride_DN) == 0x000018, "Wrong size on FGroundDeltaLegsOverride_DN");
static_assert(offsetof(FGroundDeltaLegsOverride_DN, InterpolationSpeed) == 0x000000, "Member 'FGroundDeltaLegsOverride_DN::InterpolationSpeed' has a wrong offset!");
static_assert(offsetof(FGroundDeltaLegsOverride_DN, AnimationAsset) == 0x000008, "Member 'FGroundDeltaLegsOverride_DN::AnimationAsset' has a wrong offset!");
static_assert(offsetof(FGroundDeltaLegsOverride_DN, GroundDeltaOverride) == 0x000010, "Member 'FGroundDeltaLegsOverride_DN::GroundDeltaOverride' has a wrong offset!");

// ScriptStruct DynamicNode.LocallyRepData_DN_Int
// 0x002C (0x002C - 0x0000)
struct FLocallyRepData_DN_Int final
{
public:
	struct FVector_NetQuantize100                 LastInputVector;                                   // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 LastAcceleration;                                  // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LastInputIsZero;                                   // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ThisInputIsZero;                                   // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ThisFramePivotMachine;                             // 0x001A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ThisFrameImpactMachine;                            // 0x001B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ImpactAnimationPlaySERVER : 1;                     // 0x001C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               LastControlRotation;                               // 0x0020(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocallyRepData_DN_Int) == 0x000004, "Wrong alignment on FLocallyRepData_DN_Int");
static_assert(sizeof(FLocallyRepData_DN_Int) == 0x00002C, "Wrong size on FLocallyRepData_DN_Int");
static_assert(offsetof(FLocallyRepData_DN_Int, LastInputVector) == 0x000000, "Member 'FLocallyRepData_DN_Int::LastInputVector' has a wrong offset!");
static_assert(offsetof(FLocallyRepData_DN_Int, LastAcceleration) == 0x00000C, "Member 'FLocallyRepData_DN_Int::LastAcceleration' has a wrong offset!");
static_assert(offsetof(FLocallyRepData_DN_Int, LastInputIsZero) == 0x000018, "Member 'FLocallyRepData_DN_Int::LastInputIsZero' has a wrong offset!");
static_assert(offsetof(FLocallyRepData_DN_Int, ThisInputIsZero) == 0x000019, "Member 'FLocallyRepData_DN_Int::ThisInputIsZero' has a wrong offset!");
static_assert(offsetof(FLocallyRepData_DN_Int, ThisFramePivotMachine) == 0x00001A, "Member 'FLocallyRepData_DN_Int::ThisFramePivotMachine' has a wrong offset!");
static_assert(offsetof(FLocallyRepData_DN_Int, ThisFrameImpactMachine) == 0x00001B, "Member 'FLocallyRepData_DN_Int::ThisFrameImpactMachine' has a wrong offset!");
static_assert(offsetof(FLocallyRepData_DN_Int, LastControlRotation) == 0x000020, "Member 'FLocallyRepData_DN_Int::LastControlRotation' has a wrong offset!");

// ScriptStruct DynamicNode.MaxLiftLegsOverride_DN
// 0x0018 (0x0018 - 0x0000)
struct FMaxLiftLegsOverride_DN final
{
public:
	int32                                         LegIndex;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationAsset*                        AnimationAsset;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLiftLegOverride_Left;                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLiftLegOverride_Right;                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaxLiftLegsOverride_DN) == 0x000008, "Wrong alignment on FMaxLiftLegsOverride_DN");
static_assert(sizeof(FMaxLiftLegsOverride_DN) == 0x000018, "Wrong size on FMaxLiftLegsOverride_DN");
static_assert(offsetof(FMaxLiftLegsOverride_DN, LegIndex) == 0x000000, "Member 'FMaxLiftLegsOverride_DN::LegIndex' has a wrong offset!");
static_assert(offsetof(FMaxLiftLegsOverride_DN, AnimationAsset) == 0x000008, "Member 'FMaxLiftLegsOverride_DN::AnimationAsset' has a wrong offset!");
static_assert(offsetof(FMaxLiftLegsOverride_DN, MaxLiftLegOverride_Left) == 0x000010, "Member 'FMaxLiftLegsOverride_DN::MaxLiftLegOverride_Left' has a wrong offset!");
static_assert(offsetof(FMaxLiftLegsOverride_DN, MaxLiftLegOverride_Right) == 0x000014, "Member 'FMaxLiftLegsOverride_DN::MaxLiftLegOverride_Right' has a wrong offset!");

// ScriptStruct DynamicNode.LegIndexEnabled_DN
// 0x0008 (0x0008 - 0x0000)
struct FLegIndexEnabled_DN final
{
public:
	int32                                         LegIndex;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enable;                                            // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLegIndexEnabled_DN) == 0x000004, "Wrong alignment on FLegIndexEnabled_DN");
static_assert(sizeof(FLegIndexEnabled_DN) == 0x000008, "Wrong size on FLegIndexEnabled_DN");
static_assert(offsetof(FLegIndexEnabled_DN, LegIndex) == 0x000000, "Member 'FLegIndexEnabled_DN::LegIndex' has a wrong offset!");
static_assert(offsetof(FLegIndexEnabled_DN, Enable) == 0x000004, "Member 'FLegIndexEnabled_DN::Enable' has a wrong offset!");

// ScriptStruct DynamicNode.LegsPairs_DN
// 0x0050 (0x0050 - 0x0000)
struct FLegsPairs_DN final
{
public:
	float                                         MaxLiftLegs;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLengthLegsPercent;                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftLegBoneName;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftSocketRearName;                                // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftSocketFrontName;                               // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftLegForwardVector;                              // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightLegBoneName;                                  // 0x002C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightSocketRearName;                               // 0x0034(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightSocketFrontName;                              // 0x003C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightLegForwardVector;                             // 0x0044(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegsPairs_DN) == 0x000004, "Wrong alignment on FLegsPairs_DN");
static_assert(sizeof(FLegsPairs_DN) == 0x000050, "Wrong size on FLegsPairs_DN");
static_assert(offsetof(FLegsPairs_DN, MaxLiftLegs) == 0x000000, "Member 'FLegsPairs_DN::MaxLiftLegs' has a wrong offset!");
static_assert(offsetof(FLegsPairs_DN, MaxLengthLegsPercent) == 0x000004, "Member 'FLegsPairs_DN::MaxLengthLegsPercent' has a wrong offset!");
static_assert(offsetof(FLegsPairs_DN, LeftLegBoneName) == 0x000008, "Member 'FLegsPairs_DN::LeftLegBoneName' has a wrong offset!");
static_assert(offsetof(FLegsPairs_DN, LeftSocketRearName) == 0x000010, "Member 'FLegsPairs_DN::LeftSocketRearName' has a wrong offset!");
static_assert(offsetof(FLegsPairs_DN, LeftSocketFrontName) == 0x000018, "Member 'FLegsPairs_DN::LeftSocketFrontName' has a wrong offset!");
static_assert(offsetof(FLegsPairs_DN, LeftLegForwardVector) == 0x000020, "Member 'FLegsPairs_DN::LeftLegForwardVector' has a wrong offset!");
static_assert(offsetof(FLegsPairs_DN, RightLegBoneName) == 0x00002C, "Member 'FLegsPairs_DN::RightLegBoneName' has a wrong offset!");
static_assert(offsetof(FLegsPairs_DN, RightSocketRearName) == 0x000034, "Member 'FLegsPairs_DN::RightSocketRearName' has a wrong offset!");
static_assert(offsetof(FLegsPairs_DN, RightSocketFrontName) == 0x00003C, "Member 'FLegsPairs_DN::RightSocketFrontName' has a wrong offset!");
static_assert(offsetof(FLegsPairs_DN, RightLegForwardVector) == 0x000044, "Member 'FLegsPairs_DN::RightLegForwardVector' has a wrong offset!");

// ScriptStruct DynamicNode.RootLegsPairs_DN
// 0x0048 (0x0048 - 0x0000)
struct FRootLegsPairs_DN final
{
public:
	class FName                                   RootBoneName;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundDeltaZ;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLegsPairs_DN>                  Legs;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TraceUpLen;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDownLen;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnchorSize;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeed;                                       // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionTimeLegs;                                // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionTimeLegsRotation;                        // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionTimeRoot;                                // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingTransitionCoeff;                             // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSeparateMaxLowerRoot;                           // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SeparateMaxLowerRoot;                              // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRootLegsPairs_DN) == 0x000008, "Wrong alignment on FRootLegsPairs_DN");
static_assert(sizeof(FRootLegsPairs_DN) == 0x000048, "Wrong size on FRootLegsPairs_DN");
static_assert(offsetof(FRootLegsPairs_DN, RootBoneName) == 0x000000, "Member 'FRootLegsPairs_DN::RootBoneName' has a wrong offset!");
static_assert(offsetof(FRootLegsPairs_DN, GroundDeltaZ) == 0x000008, "Member 'FRootLegsPairs_DN::GroundDeltaZ' has a wrong offset!");
static_assert(offsetof(FRootLegsPairs_DN, Legs) == 0x000010, "Member 'FRootLegsPairs_DN::Legs' has a wrong offset!");
static_assert(offsetof(FRootLegsPairs_DN, TraceUpLen) == 0x000020, "Member 'FRootLegsPairs_DN::TraceUpLen' has a wrong offset!");
static_assert(offsetof(FRootLegsPairs_DN, TraceDownLen) == 0x000024, "Member 'FRootLegsPairs_DN::TraceDownLen' has a wrong offset!");
static_assert(offsetof(FRootLegsPairs_DN, AnchorSize) == 0x000028, "Member 'FRootLegsPairs_DN::AnchorSize' has a wrong offset!");
static_assert(offsetof(FRootLegsPairs_DN, MaxRunSpeed) == 0x00002C, "Member 'FRootLegsPairs_DN::MaxRunSpeed' has a wrong offset!");
static_assert(offsetof(FRootLegsPairs_DN, TransitionTimeLegs) == 0x000030, "Member 'FRootLegsPairs_DN::TransitionTimeLegs' has a wrong offset!");
static_assert(offsetof(FRootLegsPairs_DN, TransitionTimeLegsRotation) == 0x000034, "Member 'FRootLegsPairs_DN::TransitionTimeLegsRotation' has a wrong offset!");
static_assert(offsetof(FRootLegsPairs_DN, TransitionTimeRoot) == 0x000038, "Member 'FRootLegsPairs_DN::TransitionTimeRoot' has a wrong offset!");
static_assert(offsetof(FRootLegsPairs_DN, MovingTransitionCoeff) == 0x00003C, "Member 'FRootLegsPairs_DN::MovingTransitionCoeff' has a wrong offset!");
static_assert(offsetof(FRootLegsPairs_DN, UseSeparateMaxLowerRoot) == 0x000040, "Member 'FRootLegsPairs_DN::UseSeparateMaxLowerRoot' has a wrong offset!");
static_assert(offsetof(FRootLegsPairs_DN, SeparateMaxLowerRoot) == 0x000044, "Member 'FRootLegsPairs_DN::SeparateMaxLowerRoot' has a wrong offset!");

// ScriptStruct DynamicNode.LegsPairsSimple_DN
// 0x0038 (0x0038 - 0x0000)
struct FLegsPairsSimple_DN final
{
public:
	float                                         MaxLiftLegs;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLengthLegsPercent;                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftLegBoneName;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftZOffset;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftLegForwardVector;                              // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightLegBoneName;                                  // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightZOffset;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightLegForwardVector;                             // 0x002C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegsPairsSimple_DN) == 0x000004, "Wrong alignment on FLegsPairsSimple_DN");
static_assert(sizeof(FLegsPairsSimple_DN) == 0x000038, "Wrong size on FLegsPairsSimple_DN");
static_assert(offsetof(FLegsPairsSimple_DN, MaxLiftLegs) == 0x000000, "Member 'FLegsPairsSimple_DN::MaxLiftLegs' has a wrong offset!");
static_assert(offsetof(FLegsPairsSimple_DN, MaxLengthLegsPercent) == 0x000004, "Member 'FLegsPairsSimple_DN::MaxLengthLegsPercent' has a wrong offset!");
static_assert(offsetof(FLegsPairsSimple_DN, LeftLegBoneName) == 0x000008, "Member 'FLegsPairsSimple_DN::LeftLegBoneName' has a wrong offset!");
static_assert(offsetof(FLegsPairsSimple_DN, LeftZOffset) == 0x000010, "Member 'FLegsPairsSimple_DN::LeftZOffset' has a wrong offset!");
static_assert(offsetof(FLegsPairsSimple_DN, LeftLegForwardVector) == 0x000014, "Member 'FLegsPairsSimple_DN::LeftLegForwardVector' has a wrong offset!");
static_assert(offsetof(FLegsPairsSimple_DN, RightLegBoneName) == 0x000020, "Member 'FLegsPairsSimple_DN::RightLegBoneName' has a wrong offset!");
static_assert(offsetof(FLegsPairsSimple_DN, RightZOffset) == 0x000028, "Member 'FLegsPairsSimple_DN::RightZOffset' has a wrong offset!");
static_assert(offsetof(FLegsPairsSimple_DN, RightLegForwardVector) == 0x00002C, "Member 'FLegsPairsSimple_DN::RightLegForwardVector' has a wrong offset!");

// ScriptStruct DynamicNode.RootLegsPairsSimple_DN
// 0x0048 (0x0048 - 0x0000)
struct FRootLegsPairsSimple_DN final
{
public:
	class FName                                   RootBoneName;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundDeltaZ;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLegsPairsSimple_DN>            Legs;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TraceUpLen;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDownLen;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnchorSize;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeed;                                       // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionTimeLegs;                                // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionTimeRoot;                                // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingTransitionCoeff;                             // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSeparateMaxLowerRoot;                           // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SeparateMaxLowerRoot;                              // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRootLegsPairsSimple_DN) == 0x000008, "Wrong alignment on FRootLegsPairsSimple_DN");
static_assert(sizeof(FRootLegsPairsSimple_DN) == 0x000048, "Wrong size on FRootLegsPairsSimple_DN");
static_assert(offsetof(FRootLegsPairsSimple_DN, RootBoneName) == 0x000000, "Member 'FRootLegsPairsSimple_DN::RootBoneName' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSimple_DN, GroundDeltaZ) == 0x000008, "Member 'FRootLegsPairsSimple_DN::GroundDeltaZ' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSimple_DN, Legs) == 0x000010, "Member 'FRootLegsPairsSimple_DN::Legs' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSimple_DN, TraceUpLen) == 0x000020, "Member 'FRootLegsPairsSimple_DN::TraceUpLen' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSimple_DN, TraceDownLen) == 0x000024, "Member 'FRootLegsPairsSimple_DN::TraceDownLen' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSimple_DN, AnchorSize) == 0x000028, "Member 'FRootLegsPairsSimple_DN::AnchorSize' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSimple_DN, MaxRunSpeed) == 0x00002C, "Member 'FRootLegsPairsSimple_DN::MaxRunSpeed' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSimple_DN, TransitionTimeLegs) == 0x000030, "Member 'FRootLegsPairsSimple_DN::TransitionTimeLegs' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSimple_DN, TransitionTimeRoot) == 0x000034, "Member 'FRootLegsPairsSimple_DN::TransitionTimeRoot' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSimple_DN, MovingTransitionCoeff) == 0x000038, "Member 'FRootLegsPairsSimple_DN::MovingTransitionCoeff' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSimple_DN, UseSeparateMaxLowerRoot) == 0x00003C, "Member 'FRootLegsPairsSimple_DN::UseSeparateMaxLowerRoot' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSimple_DN, SeparateMaxLowerRoot) == 0x000040, "Member 'FRootLegsPairsSimple_DN::SeparateMaxLowerRoot' has a wrong offset!");

// ScriptStruct DynamicNode.LegsPairsSSimple_DN
// 0x0040 (0x0040 - 0x0000)
struct FLegsPairsSSimple_DN final
{
public:
	float                                         MaxLiftLegs;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLengthLegsPercent;                              // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftLegBoneName;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftSocketName;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LeftLegForwardVector;                              // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightLegBoneName;                                  // 0x0024(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightSocketName;                                   // 0x002C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RightLegForwardVector;                             // 0x0034(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLegsPairsSSimple_DN) == 0x000004, "Wrong alignment on FLegsPairsSSimple_DN");
static_assert(sizeof(FLegsPairsSSimple_DN) == 0x000040, "Wrong size on FLegsPairsSSimple_DN");
static_assert(offsetof(FLegsPairsSSimple_DN, MaxLiftLegs) == 0x000000, "Member 'FLegsPairsSSimple_DN::MaxLiftLegs' has a wrong offset!");
static_assert(offsetof(FLegsPairsSSimple_DN, MaxLengthLegsPercent) == 0x000004, "Member 'FLegsPairsSSimple_DN::MaxLengthLegsPercent' has a wrong offset!");
static_assert(offsetof(FLegsPairsSSimple_DN, LeftLegBoneName) == 0x000008, "Member 'FLegsPairsSSimple_DN::LeftLegBoneName' has a wrong offset!");
static_assert(offsetof(FLegsPairsSSimple_DN, LeftSocketName) == 0x000010, "Member 'FLegsPairsSSimple_DN::LeftSocketName' has a wrong offset!");
static_assert(offsetof(FLegsPairsSSimple_DN, LeftLegForwardVector) == 0x000018, "Member 'FLegsPairsSSimple_DN::LeftLegForwardVector' has a wrong offset!");
static_assert(offsetof(FLegsPairsSSimple_DN, RightLegBoneName) == 0x000024, "Member 'FLegsPairsSSimple_DN::RightLegBoneName' has a wrong offset!");
static_assert(offsetof(FLegsPairsSSimple_DN, RightSocketName) == 0x00002C, "Member 'FLegsPairsSSimple_DN::RightSocketName' has a wrong offset!");
static_assert(offsetof(FLegsPairsSSimple_DN, RightLegForwardVector) == 0x000034, "Member 'FLegsPairsSSimple_DN::RightLegForwardVector' has a wrong offset!");

// ScriptStruct DynamicNode.RootLegsPairsSSimple_DN
// 0x0048 (0x0048 - 0x0000)
struct FRootLegsPairsSSimple_DN final
{
public:
	class FName                                   RootBoneName;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundDeltaZ;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLegsPairsSSimple_DN>           Legs;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TraceUpLen;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDownLen;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnchorSize;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeed;                                       // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionTimeLegs;                                // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionTimeRoot;                                // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingTransitionCoeff;                             // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSeparateMaxLowerRoot;                           // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SeparateMaxLowerRoot;                              // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRootLegsPairsSSimple_DN) == 0x000008, "Wrong alignment on FRootLegsPairsSSimple_DN");
static_assert(sizeof(FRootLegsPairsSSimple_DN) == 0x000048, "Wrong size on FRootLegsPairsSSimple_DN");
static_assert(offsetof(FRootLegsPairsSSimple_DN, RootBoneName) == 0x000000, "Member 'FRootLegsPairsSSimple_DN::RootBoneName' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSSimple_DN, GroundDeltaZ) == 0x000008, "Member 'FRootLegsPairsSSimple_DN::GroundDeltaZ' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSSimple_DN, Legs) == 0x000010, "Member 'FRootLegsPairsSSimple_DN::Legs' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSSimple_DN, TraceUpLen) == 0x000020, "Member 'FRootLegsPairsSSimple_DN::TraceUpLen' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSSimple_DN, TraceDownLen) == 0x000024, "Member 'FRootLegsPairsSSimple_DN::TraceDownLen' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSSimple_DN, AnchorSize) == 0x000028, "Member 'FRootLegsPairsSSimple_DN::AnchorSize' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSSimple_DN, MaxRunSpeed) == 0x00002C, "Member 'FRootLegsPairsSSimple_DN::MaxRunSpeed' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSSimple_DN, TransitionTimeLegs) == 0x000030, "Member 'FRootLegsPairsSSimple_DN::TransitionTimeLegs' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSSimple_DN, TransitionTimeRoot) == 0x000034, "Member 'FRootLegsPairsSSimple_DN::TransitionTimeRoot' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSSimple_DN, MovingTransitionCoeff) == 0x000038, "Member 'FRootLegsPairsSSimple_DN::MovingTransitionCoeff' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSSimple_DN, UseSeparateMaxLowerRoot) == 0x00003C, "Member 'FRootLegsPairsSSimple_DN::UseSeparateMaxLowerRoot' has a wrong offset!");
static_assert(offsetof(FRootLegsPairsSSimple_DN, SeparateMaxLowerRoot) == 0x000040, "Member 'FRootLegsPairsSSimple_DN::SeparateMaxLowerRoot' has a wrong offset!");

// ScriptStruct DynamicNode.SSocketPairs_DN
// 0x0010 (0x0010 - 0x0000)
struct FSSocketPairs_DN final
{
public:
	class FName                                   LeftSocketName;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightSocketName;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSSocketPairs_DN) == 0x000004, "Wrong alignment on FSSocketPairs_DN");
static_assert(sizeof(FSSocketPairs_DN) == 0x000010, "Wrong size on FSSocketPairs_DN");
static_assert(offsetof(FSSocketPairs_DN, LeftSocketName) == 0x000000, "Member 'FSSocketPairs_DN::LeftSocketName' has a wrong offset!");
static_assert(offsetof(FSSocketPairs_DN, RightSocketName) == 0x000008, "Member 'FSSocketPairs_DN::RightSocketName' has a wrong offset!");

// ScriptStruct DynamicNode.RootSSocketPairs_DN
// 0x0038 (0x0038 - 0x0000)
struct FRootSSocketPairs_DN final
{
public:
	class FName                                   RootBoneName;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundDeltaZ;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSSocketPairs_DN>               Sockets;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TraceUpLen;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceDownLen;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeed;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionTimeRoot;                                // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingTransitionCoeff;                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRootSSocketPairs_DN) == 0x000008, "Wrong alignment on FRootSSocketPairs_DN");
static_assert(sizeof(FRootSSocketPairs_DN) == 0x000038, "Wrong size on FRootSSocketPairs_DN");
static_assert(offsetof(FRootSSocketPairs_DN, RootBoneName) == 0x000000, "Member 'FRootSSocketPairs_DN::RootBoneName' has a wrong offset!");
static_assert(offsetof(FRootSSocketPairs_DN, GroundDeltaZ) == 0x000008, "Member 'FRootSSocketPairs_DN::GroundDeltaZ' has a wrong offset!");
static_assert(offsetof(FRootSSocketPairs_DN, Sockets) == 0x000010, "Member 'FRootSSocketPairs_DN::Sockets' has a wrong offset!");
static_assert(offsetof(FRootSSocketPairs_DN, TraceUpLen) == 0x000020, "Member 'FRootSSocketPairs_DN::TraceUpLen' has a wrong offset!");
static_assert(offsetof(FRootSSocketPairs_DN, TraceDownLen) == 0x000024, "Member 'FRootSSocketPairs_DN::TraceDownLen' has a wrong offset!");
static_assert(offsetof(FRootSSocketPairs_DN, MaxRunSpeed) == 0x000028, "Member 'FRootSSocketPairs_DN::MaxRunSpeed' has a wrong offset!");
static_assert(offsetof(FRootSSocketPairs_DN, TransitionTimeRoot) == 0x00002C, "Member 'FRootSSocketPairs_DN::TransitionTimeRoot' has a wrong offset!");
static_assert(offsetof(FRootSSocketPairs_DN, MovingTransitionCoeff) == 0x000030, "Member 'FRootSSocketPairs_DN::MovingTransitionCoeff' has a wrong offset!");

// ScriptStruct DynamicNode.HandTargetSocketPairs_DN
// 0x0038 (0x0038 - 0x0000)
struct FHandTargetSocketPairs_DN final
{
public:
	int32                                         HandIndex;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HandSocketName;                                    // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetSocketName;                                  // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AddUpperarmRotation;                               // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UAnimSequence*                          HandAnimation;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HandAnimPlayFromNotify;                            // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandAnimTransitionTime;                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandAnimStartMovingOffset;                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHandTargetSocketPairs_DN) == 0x000008, "Wrong alignment on FHandTargetSocketPairs_DN");
static_assert(sizeof(FHandTargetSocketPairs_DN) == 0x000038, "Wrong size on FHandTargetSocketPairs_DN");
static_assert(offsetof(FHandTargetSocketPairs_DN, HandIndex) == 0x000000, "Member 'FHandTargetSocketPairs_DN::HandIndex' has a wrong offset!");
static_assert(offsetof(FHandTargetSocketPairs_DN, HandSocketName) == 0x000004, "Member 'FHandTargetSocketPairs_DN::HandSocketName' has a wrong offset!");
static_assert(offsetof(FHandTargetSocketPairs_DN, TargetSocketName) == 0x00000C, "Member 'FHandTargetSocketPairs_DN::TargetSocketName' has a wrong offset!");
static_assert(offsetof(FHandTargetSocketPairs_DN, AddUpperarmRotation) == 0x000014, "Member 'FHandTargetSocketPairs_DN::AddUpperarmRotation' has a wrong offset!");
static_assert(offsetof(FHandTargetSocketPairs_DN, HandAnimation) == 0x000020, "Member 'FHandTargetSocketPairs_DN::HandAnimation' has a wrong offset!");
static_assert(offsetof(FHandTargetSocketPairs_DN, HandAnimPlayFromNotify) == 0x000028, "Member 'FHandTargetSocketPairs_DN::HandAnimPlayFromNotify' has a wrong offset!");
static_assert(offsetof(FHandTargetSocketPairs_DN, HandAnimTransitionTime) == 0x000030, "Member 'FHandTargetSocketPairs_DN::HandAnimTransitionTime' has a wrong offset!");
static_assert(offsetof(FHandTargetSocketPairs_DN, HandAnimStartMovingOffset) == 0x000034, "Member 'FHandTargetSocketPairs_DN::HandAnimStartMovingOffset' has a wrong offset!");

// ScriptStruct DynamicNode.VariationSetData_DN
// 0x0018 (0x0018 - 0x0000)
struct FVariationSetData_DN final
{
public:
	class UAnimationAsset*                        AnimSequence;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Repeat;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RandomStartPosition;                               // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0xB];                                        // 0x000D(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVariationSetData_DN) == 0x000008, "Wrong alignment on FVariationSetData_DN");
static_assert(sizeof(FVariationSetData_DN) == 0x000018, "Wrong size on FVariationSetData_DN");
static_assert(offsetof(FVariationSetData_DN, AnimSequence) == 0x000000, "Member 'FVariationSetData_DN::AnimSequence' has a wrong offset!");
static_assert(offsetof(FVariationSetData_DN, Repeat) == 0x000008, "Member 'FVariationSetData_DN::Repeat' has a wrong offset!");
static_assert(offsetof(FVariationSetData_DN, RandomStartPosition) == 0x00000C, "Member 'FVariationSetData_DN::RandomStartPosition' has a wrong offset!");

// ScriptStruct DynamicNode.TransitionSetData_DN
// 0x0020 (0x0020 - 0x0000)
struct FTransitionSetData_DN final
{
public:
	class UAnimationAsset*                        FromAnimSequence;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        TransitionAnimSequence;                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionTime;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayFrom;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseMultiTransition;                                // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SyncAnimationsToTransit_OnlyForMulti;              // 0x001D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SyncAnimationsFromTransit_OnlyForMulti;            // 0x001E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTransitionSetData_DN) == 0x000008, "Wrong alignment on FTransitionSetData_DN");
static_assert(sizeof(FTransitionSetData_DN) == 0x000020, "Wrong size on FTransitionSetData_DN");
static_assert(offsetof(FTransitionSetData_DN, FromAnimSequence) == 0x000000, "Member 'FTransitionSetData_DN::FromAnimSequence' has a wrong offset!");
static_assert(offsetof(FTransitionSetData_DN, TransitionAnimSequence) == 0x000008, "Member 'FTransitionSetData_DN::TransitionAnimSequence' has a wrong offset!");
static_assert(offsetof(FTransitionSetData_DN, TransitionTime) == 0x000010, "Member 'FTransitionSetData_DN::TransitionTime' has a wrong offset!");
static_assert(offsetof(FTransitionSetData_DN, PlayRate) == 0x000014, "Member 'FTransitionSetData_DN::PlayRate' has a wrong offset!");
static_assert(offsetof(FTransitionSetData_DN, PlayFrom) == 0x000018, "Member 'FTransitionSetData_DN::PlayFrom' has a wrong offset!");
static_assert(offsetof(FTransitionSetData_DN, UseMultiTransition) == 0x00001C, "Member 'FTransitionSetData_DN::UseMultiTransition' has a wrong offset!");
static_assert(offsetof(FTransitionSetData_DN, SyncAnimationsToTransit_OnlyForMulti) == 0x00001D, "Member 'FTransitionSetData_DN::SyncAnimationsToTransit_OnlyForMulti' has a wrong offset!");
static_assert(offsetof(FTransitionSetData_DN, SyncAnimationsFromTransit_OnlyForMulti) == 0x00001E, "Member 'FTransitionSetData_DN::SyncAnimationsFromTransit_OnlyForMulti' has a wrong offset!");

// ScriptStruct DynamicNode.AnimChanceData_DN
// 0x0020 (0x0020 - 0x0000)
struct FAnimChanceData_DN final
{
public:
	class UAnimationAsset*                        AnimSequence;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Default;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Chance;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanChangeAnimInRuntime;                            // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanChangeAnimWhenNewStart;                         // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PauseBetweenChangeAnimInRuntime;                   // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePauseBetweenChangeAnimOnlyOnce;                 // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RandomStartPosition;                               // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlayTillEndOfTrack;                                // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AfterPlayResetToDefault;                           // 0x001B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimChanceData_DN) == 0x000008, "Wrong alignment on FAnimChanceData_DN");
static_assert(sizeof(FAnimChanceData_DN) == 0x000020, "Wrong size on FAnimChanceData_DN");
static_assert(offsetof(FAnimChanceData_DN, AnimSequence) == 0x000000, "Member 'FAnimChanceData_DN::AnimSequence' has a wrong offset!");
static_assert(offsetof(FAnimChanceData_DN, Default) == 0x000008, "Member 'FAnimChanceData_DN::Default' has a wrong offset!");
static_assert(offsetof(FAnimChanceData_DN, Chance) == 0x00000C, "Member 'FAnimChanceData_DN::Chance' has a wrong offset!");
static_assert(offsetof(FAnimChanceData_DN, CanChangeAnimInRuntime) == 0x000010, "Member 'FAnimChanceData_DN::CanChangeAnimInRuntime' has a wrong offset!");
static_assert(offsetof(FAnimChanceData_DN, CanChangeAnimWhenNewStart) == 0x000011, "Member 'FAnimChanceData_DN::CanChangeAnimWhenNewStart' has a wrong offset!");
static_assert(offsetof(FAnimChanceData_DN, PauseBetweenChangeAnimInRuntime) == 0x000014, "Member 'FAnimChanceData_DN::PauseBetweenChangeAnimInRuntime' has a wrong offset!");
static_assert(offsetof(FAnimChanceData_DN, UsePauseBetweenChangeAnimOnlyOnce) == 0x000018, "Member 'FAnimChanceData_DN::UsePauseBetweenChangeAnimOnlyOnce' has a wrong offset!");
static_assert(offsetof(FAnimChanceData_DN, RandomStartPosition) == 0x000019, "Member 'FAnimChanceData_DN::RandomStartPosition' has a wrong offset!");
static_assert(offsetof(FAnimChanceData_DN, PlayTillEndOfTrack) == 0x00001A, "Member 'FAnimChanceData_DN::PlayTillEndOfTrack' has a wrong offset!");
static_assert(offsetof(FAnimChanceData_DN, AfterPlayResetToDefault) == 0x00001B, "Member 'FAnimChanceData_DN::AfterPlayResetToDefault' has a wrong offset!");

// ScriptStruct DynamicNode.AnimOffsetAutoUpdateData_DN
// 0x0020 (0x0020 - 0x0000)
struct FAnimOffsetAutoUpdateData_DN final
{
public:
	class UBlendSpaceBase*                        AimOffsetBlendSpace;                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XInitialDelta;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XMulti;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseXForPitch;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         YInitialDelta;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         YMulti;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolateSpeed;                                  // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimOffsetAutoUpdateData_DN) == 0x000008, "Wrong alignment on FAnimOffsetAutoUpdateData_DN");
static_assert(sizeof(FAnimOffsetAutoUpdateData_DN) == 0x000020, "Wrong size on FAnimOffsetAutoUpdateData_DN");
static_assert(offsetof(FAnimOffsetAutoUpdateData_DN, AimOffsetBlendSpace) == 0x000000, "Member 'FAnimOffsetAutoUpdateData_DN::AimOffsetBlendSpace' has a wrong offset!");
static_assert(offsetof(FAnimOffsetAutoUpdateData_DN, XInitialDelta) == 0x000008, "Member 'FAnimOffsetAutoUpdateData_DN::XInitialDelta' has a wrong offset!");
static_assert(offsetof(FAnimOffsetAutoUpdateData_DN, XMulti) == 0x00000C, "Member 'FAnimOffsetAutoUpdateData_DN::XMulti' has a wrong offset!");
static_assert(offsetof(FAnimOffsetAutoUpdateData_DN, UseXForPitch) == 0x000010, "Member 'FAnimOffsetAutoUpdateData_DN::UseXForPitch' has a wrong offset!");
static_assert(offsetof(FAnimOffsetAutoUpdateData_DN, YInitialDelta) == 0x000014, "Member 'FAnimOffsetAutoUpdateData_DN::YInitialDelta' has a wrong offset!");
static_assert(offsetof(FAnimOffsetAutoUpdateData_DN, YMulti) == 0x000018, "Member 'FAnimOffsetAutoUpdateData_DN::YMulti' has a wrong offset!");
static_assert(offsetof(FAnimOffsetAutoUpdateData_DN, InterpolateSpeed) == 0x00001C, "Member 'FAnimOffsetAutoUpdateData_DN::InterpolateSpeed' has a wrong offset!");

// ScriptStruct DynamicNode.AnimMultiNodeInstanceProxy_DN
// 0x2670 (0x2DD0 - 0x0760)
struct FAnimMultiNodeInstanceProxy_DN final : public FAnimInstanceProxy
{
public:
	uint8                                         Pad_760[0x2670];                                   // 0x0760(0x2670)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimMultiNodeInstanceProxy_DN) == 0x000010, "Wrong alignment on FAnimMultiNodeInstanceProxy_DN");
static_assert(sizeof(FAnimMultiNodeInstanceProxy_DN) == 0x002DD0, "Wrong size on FAnimMultiNodeInstanceProxy_DN");

// ScriptStruct DynamicNode.AnimNode_DynamicNodeLookAt
// 0x0208 (0x02D0 - 0x00C8)
struct FAnimNode_DynamicNodeLookAt final : public FAnimNode_SkeletalControlBase
{
public:
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneSocketTarget                      LookAtTarget;                                      // 0x00D0(0x0060)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         BoneToModify;                                      // 0x0130(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0x110];                                    // 0x0140(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOffsetIsRelative;                                 // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationOffset;                                    // 0x0254(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtClamp;                                       // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EInterpolationBlend                           InterpolationType;                                 // 0x0268(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x3];                                      // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpolationTime;                                 // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationTriggerThreashold;                    // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0x5C];                                     // 0x0274(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_DynamicNodeLookAt) == 0x000010, "Wrong alignment on FAnimNode_DynamicNodeLookAt");
static_assert(sizeof(FAnimNode_DynamicNodeLookAt) == 0x0002D0, "Wrong size on FAnimNode_DynamicNodeLookAt");
static_assert(offsetof(FAnimNode_DynamicNodeLookAt, LookAtTarget) == 0x0000D0, "Member 'FAnimNode_DynamicNodeLookAt::LookAtTarget' has a wrong offset!");
static_assert(offsetof(FAnimNode_DynamicNodeLookAt, BoneToModify) == 0x000130, "Member 'FAnimNode_DynamicNodeLookAt::BoneToModify' has a wrong offset!");
static_assert(offsetof(FAnimNode_DynamicNodeLookAt, bOffsetIsRelative) == 0x000250, "Member 'FAnimNode_DynamicNodeLookAt::bOffsetIsRelative' has a wrong offset!");
static_assert(offsetof(FAnimNode_DynamicNodeLookAt, LocationOffset) == 0x000254, "Member 'FAnimNode_DynamicNodeLookAt::LocationOffset' has a wrong offset!");
static_assert(offsetof(FAnimNode_DynamicNodeLookAt, LookAtClamp) == 0x000260, "Member 'FAnimNode_DynamicNodeLookAt::LookAtClamp' has a wrong offset!");
static_assert(offsetof(FAnimNode_DynamicNodeLookAt, InterpolationType) == 0x000268, "Member 'FAnimNode_DynamicNodeLookAt::InterpolationType' has a wrong offset!");
static_assert(offsetof(FAnimNode_DynamicNodeLookAt, InterpolationTime) == 0x00026C, "Member 'FAnimNode_DynamicNodeLookAt::InterpolationTime' has a wrong offset!");
static_assert(offsetof(FAnimNode_DynamicNodeLookAt, InterpolationTriggerThreashold) == 0x000270, "Member 'FAnimNode_DynamicNodeLookAt::InterpolationTriggerThreashold' has a wrong offset!");

// ScriptStruct DynamicNode.AnimNode_SingleNodeCustom
// 0x0040 (0x0050 - 0x0010)
struct FAnimNode_SingleNodeCustom final : public FAnimNode_Base
{
public:
	struct FPoseLink                              SourcePose;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x30];                                      // 0x0020(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_SingleNodeCustom) == 0x000008, "Wrong alignment on FAnimNode_SingleNodeCustom");
static_assert(sizeof(FAnimNode_SingleNodeCustom) == 0x000050, "Wrong size on FAnimNode_SingleNodeCustom");
static_assert(offsetof(FAnimNode_SingleNodeCustom, SourcePose) == 0x000010, "Member 'FAnimNode_SingleNodeCustom::SourcePose' has a wrong offset!");

// ScriptStruct DynamicNode.AnimNode_CPPDynamicPP
// 0x0008 (0x0018 - 0x0010)
struct FAnimNode_CPPDynamicPP final : public FAnimNode_Base
{
public:
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_CPPDynamicPP) == 0x000008, "Wrong alignment on FAnimNode_CPPDynamicPP");
static_assert(sizeof(FAnimNode_CPPDynamicPP) == 0x000018, "Wrong size on FAnimNode_CPPDynamicPP");

// ScriptStruct DynamicNode.AnimNode_CPPDynamic
// 0x0018 (0x0028 - 0x0010)
struct FAnimNode_CPPDynamic final : public FAnimNode_Base
{
public:
	struct FPoseLink                              PreviewPose;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_CPPDynamic) == 0x000008, "Wrong alignment on FAnimNode_CPPDynamic");
static_assert(sizeof(FAnimNode_CPPDynamic) == 0x000028, "Wrong size on FAnimNode_CPPDynamic");
static_assert(offsetof(FAnimNode_CPPDynamic, PreviewPose) == 0x000010, "Member 'FAnimNode_CPPDynamic::PreviewPose' has a wrong offset!");

// ScriptStruct DynamicNode.AnimNode_DynamicNodeHub
// 0x0038 (0x0048 - 0x0010)
struct FAnimNode_DynamicNodeHub final : public FAnimNode_Base
{
public:
	struct FPoseLink                              PurePoseDN;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              PostProcDN;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FPoseLink                              ProcPose;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_DynamicNodeHub) == 0x000008, "Wrong alignment on FAnimNode_DynamicNodeHub");
static_assert(sizeof(FAnimNode_DynamicNodeHub) == 0x000048, "Wrong size on FAnimNode_DynamicNodeHub");
static_assert(offsetof(FAnimNode_DynamicNodeHub, PurePoseDN) == 0x000010, "Member 'FAnimNode_DynamicNodeHub::PurePoseDN' has a wrong offset!");
static_assert(offsetof(FAnimNode_DynamicNodeHub, PostProcDN) == 0x000020, "Member 'FAnimNode_DynamicNodeHub::PostProcDN' has a wrong offset!");
static_assert(offsetof(FAnimNode_DynamicNodeHub, ProcPose) == 0x000030, "Member 'FAnimNode_DynamicNodeHub::ProcPose' has a wrong offset!");

// ScriptStruct DynamicNode.AnimNode_DynamicNodeIKHandsRetarget
// 0x0148 (0x0210 - 0x00C8)
struct alignas(0x10) FAnimNode_DynamicNodeIKHandsRetarget final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         IKBone;                                            // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ClampLength;                                       // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HandForwardVector;                                 // 0x00DC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnchorSize;                                        // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bAllowStretching : 1;                              // 0x00EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartStretchRatio;                                 // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStretchScale;                                   // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bMaintainEffectorRelRot : 1;                       // 0x00F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               HandRotation;                                      // 0x0100(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ShoulderRotation;                                  // 0x010C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                EffectorLocation;                                  // 0x0118(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0xEC];                                     // 0x0124(0x00EC)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_DynamicNodeIKHandsRetarget) == 0x000010, "Wrong alignment on FAnimNode_DynamicNodeIKHandsRetarget");
static_assert(sizeof(FAnimNode_DynamicNodeIKHandsRetarget) == 0x000210, "Wrong size on FAnimNode_DynamicNodeIKHandsRetarget");
static_assert(offsetof(FAnimNode_DynamicNodeIKHandsRetarget, IKBone) == 0x0000C8, "Member 'FAnimNode_DynamicNodeIKHandsRetarget::IKBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_DynamicNodeIKHandsRetarget, ClampLength) == 0x0000D8, "Member 'FAnimNode_DynamicNodeIKHandsRetarget::ClampLength' has a wrong offset!");
static_assert(offsetof(FAnimNode_DynamicNodeIKHandsRetarget, HandForwardVector) == 0x0000DC, "Member 'FAnimNode_DynamicNodeIKHandsRetarget::HandForwardVector' has a wrong offset!");
static_assert(offsetof(FAnimNode_DynamicNodeIKHandsRetarget, AnchorSize) == 0x0000E8, "Member 'FAnimNode_DynamicNodeIKHandsRetarget::AnchorSize' has a wrong offset!");
static_assert(offsetof(FAnimNode_DynamicNodeIKHandsRetarget, StartStretchRatio) == 0x0000F0, "Member 'FAnimNode_DynamicNodeIKHandsRetarget::StartStretchRatio' has a wrong offset!");
static_assert(offsetof(FAnimNode_DynamicNodeIKHandsRetarget, MaxStretchScale) == 0x0000F4, "Member 'FAnimNode_DynamicNodeIKHandsRetarget::MaxStretchScale' has a wrong offset!");
static_assert(offsetof(FAnimNode_DynamicNodeIKHandsRetarget, HandRotation) == 0x000100, "Member 'FAnimNode_DynamicNodeIKHandsRetarget::HandRotation' has a wrong offset!");
static_assert(offsetof(FAnimNode_DynamicNodeIKHandsRetarget, ShoulderRotation) == 0x00010C, "Member 'FAnimNode_DynamicNodeIKHandsRetarget::ShoulderRotation' has a wrong offset!");
static_assert(offsetof(FAnimNode_DynamicNodeIKHandsRetarget, EffectorLocation) == 0x000118, "Member 'FAnimNode_DynamicNodeIKHandsRetarget::EffectorLocation' has a wrong offset!");

// ScriptStruct DynamicNode.AnimNode_DynamicNodeIKHands
// 0x0040 (0x0108 - 0x00C8)
struct FAnimNode_DynamicNodeIKHands final : public FAnimNode_SkeletalControlBase
{
public:
	uint8                                         Pad_C8[0x40];                                      // 0x00C8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_DynamicNodeIKHands) == 0x000008, "Wrong alignment on FAnimNode_DynamicNodeIKHands");
static_assert(sizeof(FAnimNode_DynamicNodeIKHands) == 0x000108, "Wrong size on FAnimNode_DynamicNodeIKHands");

// ScriptStruct DynamicNode.AnimNode_DynamicNodeIkLegsSolver
// 0x0268 (0x0330 - 0x00C8)
struct alignas(0x10) FAnimNode_DynamicNodeIkLegsSolver final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         IKBone;                                            // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         IKBone_2;                                          // 0x00D8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bTakeRotationFromEffectorSpace : 1;                // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMaintainEffectorRelRot : 1;                       // 0x00E8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E9[0x247];                                     // 0x00E9(0x0247)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_DynamicNodeIkLegsSolver) == 0x000010, "Wrong alignment on FAnimNode_DynamicNodeIkLegsSolver");
static_assert(sizeof(FAnimNode_DynamicNodeIkLegsSolver) == 0x000330, "Wrong size on FAnimNode_DynamicNodeIkLegsSolver");
static_assert(offsetof(FAnimNode_DynamicNodeIkLegsSolver, IKBone) == 0x0000C8, "Member 'FAnimNode_DynamicNodeIkLegsSolver::IKBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_DynamicNodeIkLegsSolver, IKBone_2) == 0x0000D8, "Member 'FAnimNode_DynamicNodeIkLegsSolver::IKBone_2' has a wrong offset!");

// ScriptStruct DynamicNode.AnimNode_LookAt_DN
// 0x0168 (0x0230 - 0x00C8)
struct FAnimNode_LookAt_DN final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         BoneToModify;                                      // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                BoneOffsetCS;                                      // 0x00D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0xC];                                       // 0x00E4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneSocketTarget                      LookAtTarget;                                      // 0x00F0(0x0060)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LookAtLocation;                                    // 0x0150(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAxis                                  LookAt_Axis;                                       // 0x015C(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseLookUpAxis;                                    // 0x016C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInterpolationBlend                           InterpolationType;                                 // 0x016D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16E[0x2];                                      // 0x016E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAxis                                  LookUp_Axis;                                       // 0x0170(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_180[0xC];                                      // 0x0180(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          UseMultiBeforeClamp;                               // 0x018C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D[0x3];                                      // 0x018D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotationMulti;                                     // 0x0190(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         YawAddMultiRelativeToPitchAndRoll;                 // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtClamp;                                       // 0x01A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ProjectPitchRoll;                                  // 0x01A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A5[0x3];                                      // 0x01A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtClampXY;                                     // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtClampZUp;                                    // 0x01AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtClampZBot;                                   // 0x01B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtClampZUp_YawLimitMax;                        // 0x01B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtClampZBot_YawLimitMax;                       // 0x01B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtClampZ_YawLimitBlend;                        // 0x01BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseQuatInterpolation;                              // 0x01C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x3];                                      // 0x01C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpolationQuatSpeed;                            // 0x01C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationTime;                                 // 0x01C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationTriggerThreashold;                    // 0x01CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D0[0x60];                                     // 0x01D0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_LookAt_DN) == 0x000010, "Wrong alignment on FAnimNode_LookAt_DN");
static_assert(sizeof(FAnimNode_LookAt_DN) == 0x000230, "Wrong size on FAnimNode_LookAt_DN");
static_assert(offsetof(FAnimNode_LookAt_DN, BoneToModify) == 0x0000C8, "Member 'FAnimNode_LookAt_DN::BoneToModify' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, BoneOffsetCS) == 0x0000D8, "Member 'FAnimNode_LookAt_DN::BoneOffsetCS' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, LookAtTarget) == 0x0000F0, "Member 'FAnimNode_LookAt_DN::LookAtTarget' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, LookAtLocation) == 0x000150, "Member 'FAnimNode_LookAt_DN::LookAtLocation' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, LookAt_Axis) == 0x00015C, "Member 'FAnimNode_LookAt_DN::LookAt_Axis' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, bUseLookUpAxis) == 0x00016C, "Member 'FAnimNode_LookAt_DN::bUseLookUpAxis' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, InterpolationType) == 0x00016D, "Member 'FAnimNode_LookAt_DN::InterpolationType' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, LookUp_Axis) == 0x000170, "Member 'FAnimNode_LookAt_DN::LookUp_Axis' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, UseMultiBeforeClamp) == 0x00018C, "Member 'FAnimNode_LookAt_DN::UseMultiBeforeClamp' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, RotationMulti) == 0x000190, "Member 'FAnimNode_LookAt_DN::RotationMulti' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, YawAddMultiRelativeToPitchAndRoll) == 0x00019C, "Member 'FAnimNode_LookAt_DN::YawAddMultiRelativeToPitchAndRoll' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, LookAtClamp) == 0x0001A0, "Member 'FAnimNode_LookAt_DN::LookAtClamp' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, ProjectPitchRoll) == 0x0001A4, "Member 'FAnimNode_LookAt_DN::ProjectPitchRoll' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, LookAtClampXY) == 0x0001A8, "Member 'FAnimNode_LookAt_DN::LookAtClampXY' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, LookAtClampZUp) == 0x0001AC, "Member 'FAnimNode_LookAt_DN::LookAtClampZUp' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, LookAtClampZBot) == 0x0001B0, "Member 'FAnimNode_LookAt_DN::LookAtClampZBot' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, LookAtClampZUp_YawLimitMax) == 0x0001B4, "Member 'FAnimNode_LookAt_DN::LookAtClampZUp_YawLimitMax' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, LookAtClampZBot_YawLimitMax) == 0x0001B8, "Member 'FAnimNode_LookAt_DN::LookAtClampZBot_YawLimitMax' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, LookAtClampZ_YawLimitBlend) == 0x0001BC, "Member 'FAnimNode_LookAt_DN::LookAtClampZ_YawLimitBlend' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, UseQuatInterpolation) == 0x0001C0, "Member 'FAnimNode_LookAt_DN::UseQuatInterpolation' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, InterpolationQuatSpeed) == 0x0001C4, "Member 'FAnimNode_LookAt_DN::InterpolationQuatSpeed' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, InterpolationTime) == 0x0001C8, "Member 'FAnimNode_LookAt_DN::InterpolationTime' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAt_DN, InterpolationTriggerThreashold) == 0x0001CC, "Member 'FAnimNode_LookAt_DN::InterpolationTriggerThreashold' has a wrong offset!");

// ScriptStruct DynamicNode.AnimNode_CCDIKCustom
// 0x00F8 (0x01C0 - 0x00C8)
struct FAnimNode_CCDIKCustom final : public FAnimNode_SkeletalControlBase
{
public:
	struct FVector                                EffectorLocation;                                  // 0x00C8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneControlSpace                             EffectorLocationSpace;                             // 0x00D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0xB];                                       // 0x00D5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneSocketTarget                      EffectorTarget;                                    // 0x00E0(0x0060)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         MiddleOfHandBone;                                  // 0x0140(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         UpperarmBone;                                      // 0x0150(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                UpperarmSolverHandMoveDir_CS;                      // 0x0160(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperarmSolverRotateMulti;                         // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperarmSolverRotationMulti_Negation;              // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperarmSolverForwardMoveMulti;                    // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperarmSolverForwardMoveMulti_Negation;           // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                UpperarmSolverForwardMoveDir;                      // 0x017C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShoulderStretchCoef;                               // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShoulderStretchSideMoveDivider;                    // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpperArmRotationLimit;                             // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Precision;                                         // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxIterations;                                     // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStartFromTail;                                    // 0x019C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19D[0x3];                                      // 0x019D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 RotationLimitPerJoints;                            // 0x01A0(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B0[0x10];                                     // 0x01B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_CCDIKCustom) == 0x000010, "Wrong alignment on FAnimNode_CCDIKCustom");
static_assert(sizeof(FAnimNode_CCDIKCustom) == 0x0001C0, "Wrong size on FAnimNode_CCDIKCustom");
static_assert(offsetof(FAnimNode_CCDIKCustom, EffectorLocation) == 0x0000C8, "Member 'FAnimNode_CCDIKCustom::EffectorLocation' has a wrong offset!");
static_assert(offsetof(FAnimNode_CCDIKCustom, EffectorLocationSpace) == 0x0000D4, "Member 'FAnimNode_CCDIKCustom::EffectorLocationSpace' has a wrong offset!");
static_assert(offsetof(FAnimNode_CCDIKCustom, EffectorTarget) == 0x0000E0, "Member 'FAnimNode_CCDIKCustom::EffectorTarget' has a wrong offset!");
static_assert(offsetof(FAnimNode_CCDIKCustom, MiddleOfHandBone) == 0x000140, "Member 'FAnimNode_CCDIKCustom::MiddleOfHandBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_CCDIKCustom, UpperarmBone) == 0x000150, "Member 'FAnimNode_CCDIKCustom::UpperarmBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_CCDIKCustom, UpperarmSolverHandMoveDir_CS) == 0x000160, "Member 'FAnimNode_CCDIKCustom::UpperarmSolverHandMoveDir_CS' has a wrong offset!");
static_assert(offsetof(FAnimNode_CCDIKCustom, UpperarmSolverRotateMulti) == 0x00016C, "Member 'FAnimNode_CCDIKCustom::UpperarmSolverRotateMulti' has a wrong offset!");
static_assert(offsetof(FAnimNode_CCDIKCustom, UpperarmSolverRotationMulti_Negation) == 0x000170, "Member 'FAnimNode_CCDIKCustom::UpperarmSolverRotationMulti_Negation' has a wrong offset!");
static_assert(offsetof(FAnimNode_CCDIKCustom, UpperarmSolverForwardMoveMulti) == 0x000174, "Member 'FAnimNode_CCDIKCustom::UpperarmSolverForwardMoveMulti' has a wrong offset!");
static_assert(offsetof(FAnimNode_CCDIKCustom, UpperarmSolverForwardMoveMulti_Negation) == 0x000178, "Member 'FAnimNode_CCDIKCustom::UpperarmSolverForwardMoveMulti_Negation' has a wrong offset!");
static_assert(offsetof(FAnimNode_CCDIKCustom, UpperarmSolverForwardMoveDir) == 0x00017C, "Member 'FAnimNode_CCDIKCustom::UpperarmSolverForwardMoveDir' has a wrong offset!");
static_assert(offsetof(FAnimNode_CCDIKCustom, ShoulderStretchCoef) == 0x000188, "Member 'FAnimNode_CCDIKCustom::ShoulderStretchCoef' has a wrong offset!");
static_assert(offsetof(FAnimNode_CCDIKCustom, ShoulderStretchSideMoveDivider) == 0x00018C, "Member 'FAnimNode_CCDIKCustom::ShoulderStretchSideMoveDivider' has a wrong offset!");
static_assert(offsetof(FAnimNode_CCDIKCustom, UpperArmRotationLimit) == 0x000190, "Member 'FAnimNode_CCDIKCustom::UpperArmRotationLimit' has a wrong offset!");
static_assert(offsetof(FAnimNode_CCDIKCustom, Precision) == 0x000194, "Member 'FAnimNode_CCDIKCustom::Precision' has a wrong offset!");
static_assert(offsetof(FAnimNode_CCDIKCustom, MaxIterations) == 0x000198, "Member 'FAnimNode_CCDIKCustom::MaxIterations' has a wrong offset!");
static_assert(offsetof(FAnimNode_CCDIKCustom, bStartFromTail) == 0x00019C, "Member 'FAnimNode_CCDIKCustom::bStartFromTail' has a wrong offset!");
static_assert(offsetof(FAnimNode_CCDIKCustom, RotationLimitPerJoints) == 0x0001A0, "Member 'FAnimNode_CCDIKCustom::RotationLimitPerJoints' has a wrong offset!");

// ScriptStruct DynamicNode.AnimNode_LayeredBoneBlendCustom
// 0x00B0 (0x00C0 - 0x0010)
struct FAnimNode_LayeredBoneBlendCustom final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FPoseLink>                      BlendPoses;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FInputBlendPose>                LayerSetup;                                        // 0x0030(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 BlendWeights;                                      // 0x0040(0x0010)(Edit, BlueprintVisible, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bMeshSpaceRotationBlend;                           // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMeshSpaceScaleBlend;                              // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurveBlendOption                             CurveBlendOption;                                  // 0x0052(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlendRootMotionBasedOnRootBone;                   // 0x0053(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LODThreshold;                                      // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPerBoneBlendWeight>            PerBoneBlendWeights;                               // 0x0060(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FGuid                                  SkeletonGuid;                                      // 0x0070(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  VirtualBoneGuid;                                   // 0x0080(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x30];                                      // 0x0090(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_LayeredBoneBlendCustom) == 0x000008, "Wrong alignment on FAnimNode_LayeredBoneBlendCustom");
static_assert(sizeof(FAnimNode_LayeredBoneBlendCustom) == 0x0000C0, "Wrong size on FAnimNode_LayeredBoneBlendCustom");
static_assert(offsetof(FAnimNode_LayeredBoneBlendCustom, BasePose) == 0x000010, "Member 'FAnimNode_LayeredBoneBlendCustom::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_LayeredBoneBlendCustom, BlendPoses) == 0x000020, "Member 'FAnimNode_LayeredBoneBlendCustom::BlendPoses' has a wrong offset!");
static_assert(offsetof(FAnimNode_LayeredBoneBlendCustom, LayerSetup) == 0x000030, "Member 'FAnimNode_LayeredBoneBlendCustom::LayerSetup' has a wrong offset!");
static_assert(offsetof(FAnimNode_LayeredBoneBlendCustom, BlendWeights) == 0x000040, "Member 'FAnimNode_LayeredBoneBlendCustom::BlendWeights' has a wrong offset!");
static_assert(offsetof(FAnimNode_LayeredBoneBlendCustom, bMeshSpaceRotationBlend) == 0x000050, "Member 'FAnimNode_LayeredBoneBlendCustom::bMeshSpaceRotationBlend' has a wrong offset!");
static_assert(offsetof(FAnimNode_LayeredBoneBlendCustom, bMeshSpaceScaleBlend) == 0x000051, "Member 'FAnimNode_LayeredBoneBlendCustom::bMeshSpaceScaleBlend' has a wrong offset!");
static_assert(offsetof(FAnimNode_LayeredBoneBlendCustom, CurveBlendOption) == 0x000052, "Member 'FAnimNode_LayeredBoneBlendCustom::CurveBlendOption' has a wrong offset!");
static_assert(offsetof(FAnimNode_LayeredBoneBlendCustom, bBlendRootMotionBasedOnRootBone) == 0x000053, "Member 'FAnimNode_LayeredBoneBlendCustom::bBlendRootMotionBasedOnRootBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_LayeredBoneBlendCustom, LODThreshold) == 0x000058, "Member 'FAnimNode_LayeredBoneBlendCustom::LODThreshold' has a wrong offset!");
static_assert(offsetof(FAnimNode_LayeredBoneBlendCustom, PerBoneBlendWeights) == 0x000060, "Member 'FAnimNode_LayeredBoneBlendCustom::PerBoneBlendWeights' has a wrong offset!");
static_assert(offsetof(FAnimNode_LayeredBoneBlendCustom, SkeletonGuid) == 0x000070, "Member 'FAnimNode_LayeredBoneBlendCustom::SkeletonGuid' has a wrong offset!");
static_assert(offsetof(FAnimNode_LayeredBoneBlendCustom, VirtualBoneGuid) == 0x000080, "Member 'FAnimNode_LayeredBoneBlendCustom::VirtualBoneGuid' has a wrong offset!");

// ScriptStruct DynamicNode.AnimNode_Blend_DN
// 0x0010 (0x00D8 - 0x00C8)
struct FAnimNode_Blend_DN final : public FAnimNode_TwoWayBlend
{
public:
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_Blend_DN) == 0x000008, "Wrong alignment on FAnimNode_Blend_DN");
static_assert(sizeof(FAnimNode_Blend_DN) == 0x0000D8, "Wrong size on FAnimNode_Blend_DN");

// ScriptStruct DynamicNode.AnimNode_PoseSnapshot_DN
// 0x0030 (0x00C0 - 0x0090)
struct alignas(0x10) FAnimNode_PoseSnapshot_DN final : public FAnimNode_PoseSnapshot
{
public:
	uint8                                         Pad_90[0x30];                                      // 0x0090(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_PoseSnapshot_DN) == 0x000010, "Wrong alignment on FAnimNode_PoseSnapshot_DN");
static_assert(sizeof(FAnimNode_PoseSnapshot_DN) == 0x0000C0, "Wrong size on FAnimNode_PoseSnapshot_DN");

// ScriptStruct DynamicNode.AnimNode_DynamicNodeCCDIKHands
// 0x0058 (0x0120 - 0x00C8)
struct FAnimNode_DynamicNodeCCDIKHands final : public FAnimNode_SkeletalControlBase
{
public:
	uint8                                         Pad_C8[0x58];                                      // 0x00C8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_DynamicNodeCCDIKHands) == 0x000008, "Wrong alignment on FAnimNode_DynamicNodeCCDIKHands");
static_assert(sizeof(FAnimNode_DynamicNodeCCDIKHands) == 0x000120, "Wrong size on FAnimNode_DynamicNodeCCDIKHands");

}

