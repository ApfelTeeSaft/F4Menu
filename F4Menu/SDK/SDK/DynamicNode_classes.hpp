#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DynamicNode

#include "Basic.hpp"

#include "AIModule_classes.hpp"
#include "PhysicsCore_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "DynamicNode_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Class DynamicNode.LoopNAnimationAsset_DN
// 0x0030 (0x01E0 - 0x01B0)
class ULoopNAnimationAsset_DN final : public UAnimSequence
{
public:
	class UAnimSequence*                          AnimSequence;                                      // 0x01B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LoopStartNotify;                                   // 0x01B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LoopEndNotify;                                     // 0x01C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TransitionTime;                                    // 0x01C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x01CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartLoopingDeltaTime;                             // 0x01D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0xC];                                      // 0x01D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoopNAnimationAsset_DN">();
	}
	static class ULoopNAnimationAsset_DN* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoopNAnimationAsset_DN>();
	}
};
static_assert(alignof(ULoopNAnimationAsset_DN) == 0x000008, "Wrong alignment on ULoopNAnimationAsset_DN");
static_assert(sizeof(ULoopNAnimationAsset_DN) == 0x0001E0, "Wrong size on ULoopNAnimationAsset_DN");
static_assert(offsetof(ULoopNAnimationAsset_DN, AnimSequence) == 0x0001B0, "Member 'ULoopNAnimationAsset_DN::AnimSequence' has a wrong offset!");
static_assert(offsetof(ULoopNAnimationAsset_DN, LoopStartNotify) == 0x0001B8, "Member 'ULoopNAnimationAsset_DN::LoopStartNotify' has a wrong offset!");
static_assert(offsetof(ULoopNAnimationAsset_DN, LoopEndNotify) == 0x0001C0, "Member 'ULoopNAnimationAsset_DN::LoopEndNotify' has a wrong offset!");
static_assert(offsetof(ULoopNAnimationAsset_DN, TransitionTime) == 0x0001C8, "Member 'ULoopNAnimationAsset_DN::TransitionTime' has a wrong offset!");
static_assert(offsetof(ULoopNAnimationAsset_DN, PlayRate) == 0x0001CC, "Member 'ULoopNAnimationAsset_DN::PlayRate' has a wrong offset!");
static_assert(offsetof(ULoopNAnimationAsset_DN, StartLoopingDeltaTime) == 0x0001D0, "Member 'ULoopNAnimationAsset_DN::StartLoopingDeltaTime' has a wrong offset!");

// Class DynamicNode.SubtractIntersectionZone_DN
// 0x0000 (0x0258 - 0x0258)
class ASubtractIntersectionZone_DN final : public AVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtractIntersectionZone_DN">();
	}
	static class ASubtractIntersectionZone_DN* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASubtractIntersectionZone_DN>();
	}
};
static_assert(alignof(ASubtractIntersectionZone_DN) == 0x000008, "Wrong alignment on ASubtractIntersectionZone_DN");
static_assert(sizeof(ASubtractIntersectionZone_DN) == 0x000258, "Wrong size on ASubtractIntersectionZone_DN");

// Class DynamicNode.PropsActorZone_DN
// 0x0038 (0x0290 - 0x0258)
class APropsActorZone_DN final : public AVolume
{
public:
	TArray<class AActionPropsActor_DN*>           PropsActorArray;                                   // 0x0258(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   SpecificTargetSocketName;                          // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AttachToSocket;                                    // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x3];                                      // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachToSocketName;                                // 0x0274(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASubtractIntersectionZone_DN*>   SubtractIntersectionZoneArray;                     // 0x0280(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropsActorZone_DN">();
	}
	static class APropsActorZone_DN* GetDefaultObj()
	{
		return GetDefaultObjImpl<APropsActorZone_DN>();
	}
};
static_assert(alignof(APropsActorZone_DN) == 0x000008, "Wrong alignment on APropsActorZone_DN");
static_assert(sizeof(APropsActorZone_DN) == 0x000290, "Wrong size on APropsActorZone_DN");
static_assert(offsetof(APropsActorZone_DN, PropsActorArray) == 0x000258, "Member 'APropsActorZone_DN::PropsActorArray' has a wrong offset!");
static_assert(offsetof(APropsActorZone_DN, SpecificTargetSocketName) == 0x000268, "Member 'APropsActorZone_DN::SpecificTargetSocketName' has a wrong offset!");
static_assert(offsetof(APropsActorZone_DN, AttachToSocket) == 0x000270, "Member 'APropsActorZone_DN::AttachToSocket' has a wrong offset!");
static_assert(offsetof(APropsActorZone_DN, AttachToSocketName) == 0x000274, "Member 'APropsActorZone_DN::AttachToSocketName' has a wrong offset!");
static_assert(offsetof(APropsActorZone_DN, SubtractIntersectionZoneArray) == 0x000280, "Member 'APropsActorZone_DN::SubtractIntersectionZoneArray' has a wrong offset!");

// Class DynamicNode.AnimTransitionSet_DN
// 0x0080 (0x0230 - 0x01B0)
class UAnimTransitionSet_DN final : public UAnimSequence
{
public:
	TMap<class UAnimationAsset*, struct FTransitionSetData_DN> AnimTransitionMap;                                 // 0x01B0(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        Animation;                                         // 0x0200(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208[0x28];                                     // 0x0208(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetManuallyNextTransitionAnimation(const struct FTransitionSetData_DN& NextTransitionAnimation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimTransitionSet_DN">();
	}
	static class UAnimTransitionSet_DN* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimTransitionSet_DN>();
	}
};
static_assert(alignof(UAnimTransitionSet_DN) == 0x000008, "Wrong alignment on UAnimTransitionSet_DN");
static_assert(sizeof(UAnimTransitionSet_DN) == 0x000230, "Wrong size on UAnimTransitionSet_DN");
static_assert(offsetof(UAnimTransitionSet_DN, AnimTransitionMap) == 0x0001B0, "Member 'UAnimTransitionSet_DN::AnimTransitionMap' has a wrong offset!");
static_assert(offsetof(UAnimTransitionSet_DN, Animation) == 0x000200, "Member 'UAnimTransitionSet_DN::Animation' has a wrong offset!");

// Class DynamicNode.AnimMultiNodeInstancePostProcess_DN
// 0x0000 (0x02C0 - 0x02C0)
class UAnimMultiNodeInstancePostProcess_DN final : public UAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimMultiNodeInstancePostProcess_DN">();
	}
	static class UAnimMultiNodeInstancePostProcess_DN* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimMultiNodeInstancePostProcess_DN>();
	}
};
static_assert(alignof(UAnimMultiNodeInstancePostProcess_DN) == 0x000010, "Wrong alignment on UAnimMultiNodeInstancePostProcess_DN");
static_assert(sizeof(UAnimMultiNodeInstancePostProcess_DN) == 0x0002C0, "Wrong size on UAnimMultiNodeInstancePostProcess_DN");

// Class DynamicNode.AnimChanceSet_DN
// 0x0068 (0x0218 - 0x01B0)
class UAnimChanceSet_DN final : public UAnimSequence
{
public:
	class UAnimationAsset*                        NextAnimationClient;                               // 0x01B0(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanChangeAnimInRuntimeOutClient;                   // 0x01B8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNextAssetStartFromRandomPosClient;                // 0x01B9(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BA[0x6];                                      // 0x01BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAnimChanceData_DN>             AnimSequenceArray;                                 // 0x01C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         PauseBetweenChoices;                               // 0x01D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x44];                                     // 0x01D4(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearNextIndex();
	class UAnimationAsset* GetDefaultAnimation();
	void OnRep_NextAnimationClient();
	void RemoveParentAsset();
	void SetNextAnimation(class UAnimationAsset* AnimSequence, bool CanChangeAnimInRuntimeOutOverride);
	void SetNextIndex(int32 Param_Index, bool CanChangeAnimInRuntimeOutOverride);
	void SetParentAsset(class UAnimChanceSet_DN* ParentChanceSet, bool UseParentDataOnlyOnce);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimChanceSet_DN">();
	}
	static class UAnimChanceSet_DN* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimChanceSet_DN>();
	}
};
static_assert(alignof(UAnimChanceSet_DN) == 0x000008, "Wrong alignment on UAnimChanceSet_DN");
static_assert(sizeof(UAnimChanceSet_DN) == 0x000218, "Wrong size on UAnimChanceSet_DN");
static_assert(offsetof(UAnimChanceSet_DN, NextAnimationClient) == 0x0001B0, "Member 'UAnimChanceSet_DN::NextAnimationClient' has a wrong offset!");
static_assert(offsetof(UAnimChanceSet_DN, CanChangeAnimInRuntimeOutClient) == 0x0001B8, "Member 'UAnimChanceSet_DN::CanChangeAnimInRuntimeOutClient' has a wrong offset!");
static_assert(offsetof(UAnimChanceSet_DN, bNextAssetStartFromRandomPosClient) == 0x0001B9, "Member 'UAnimChanceSet_DN::bNextAssetStartFromRandomPosClient' has a wrong offset!");
static_assert(offsetof(UAnimChanceSet_DN, AnimSequenceArray) == 0x0001C0, "Member 'UAnimChanceSet_DN::AnimSequenceArray' has a wrong offset!");
static_assert(offsetof(UAnimChanceSet_DN, PauseBetweenChoices) == 0x0001D0, "Member 'UAnimChanceSet_DN::PauseBetweenChoices' has a wrong offset!");

// Class DynamicNode.AnimMultiNodeInstance_DN
// 0x1300 (0x15C0 - 0x02C0)
class UAnimMultiNodeInstance_DN : public UAnimInstance
{
public:
	uint8                                         Pad_2B8[0x900];                                    // 0x02B8(0x0900)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRotator>                       LastLookAtRotations;                               // 0x0BB8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC8[0x9F8];                                    // 0x0BC8(0x09F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugFloatInput(float DebugVelue);
	void EquipThingCallBack(uint8 StackPriority, class FName BoneName, class FName NotifyName, const class UAnimSequenceBase* LinkedSequence, bool EndOfTrack);
	void GetBlendSpaceInput(struct FVector* InBlendInput, class FName BoneName, bool GetTarget, bool ForceGet2Multi);
	float GetLength(class FName BoneName);
	void ImpactHandleCallBack(uint8 StackPriority, class FName BoneName, class FName NotifyName, const class UAnimSequenceBase* LinkedSequence, bool EndOfTrack);
	bool MultiTransitionToMontageFromCurPose(class UAnimMontage* AnimationAsset, float TransitionTime, bool bIsLooping, float InPlayRate, class FName PlayFromSection, float StartingPosition, bool CheckSameAsset, bool UseSyncGroups);
	void PlayAnim(bool bIsLooping, float InPlayRate, float InStartPosition);
	void SetBlendSpaceInput(const struct FVector& InBlendInput, class FName BoneName, bool Instantly, bool ForceSetNOTMultiAsset);
	void SetBlendSpaceInputBlendingThreshold(float BlendingThreshold);
	void SetLooping(bool bIsLooping, class FName BoneName);
	void SetPlaying(bool bIsPlaying, class FName BoneName);
	void SetPlayRate(float InPlayRate, class FName BoneName);
	void SetPosition(float InPosition, class FName BoneName, bool bFireNotifies);
	void SetPositionWithPreviousTime(float InPosition, float InPreviousTime, class FName BoneName, bool bFireNotifies);
	void SetPreviewCurveOverride(const class FName& PoseName, float Value, bool bRemoveIfZero);
	void SetReverse(bool bInReverse, class FName BoneName);
	void StopAllAnimation();
	bool TransitionToAnimFromCurPose_Notify(class UAnimationAsset* ToNewAsset, class FName PlayFromNotify, class FName PlayTillNotify, float TransitionTime, float InPlayRate, bool CheckTheSameAsset);
	bool TransitionToAnimFromCurPose_NotifyTill(class UAnimationAsset* ToNewAsset, float StartFrom, class FName PlayTillNotify, float TransitionTime, float InPlayRate, bool CheckTheSameAsset);
	bool TransitionToMontageFromCurPose(class UAnimMontage* AnimationAsset, float TransitionTime, bool bIsLooping, float InPlayRate, class FName PlayFromSection, float StartingPosition, bool CheckSameAsset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimMultiNodeInstance_DN">();
	}
	static class UAnimMultiNodeInstance_DN* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimMultiNodeInstance_DN>();
	}
};
static_assert(alignof(UAnimMultiNodeInstance_DN) == 0x000010, "Wrong alignment on UAnimMultiNodeInstance_DN");
static_assert(sizeof(UAnimMultiNodeInstance_DN) == 0x0015C0, "Wrong size on UAnimMultiNodeInstance_DN");
static_assert(offsetof(UAnimMultiNodeInstance_DN, LastLookAtRotations) == 0x000BB8, "Member 'UAnimMultiNodeInstance_DN::LastLookAtRotations' has a wrong offset!");

// Class DynamicNode.AnimVariationSet_DN
// 0x0030 (0x01E0 - 0x01B0)
class UAnimVariationSet_DN final : public UAnimSequence
{
public:
	TArray<struct FVariationSetData_DN>           AnimSequenceArray;                                 // 0x01B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimVariationSet_DN*>           LinkedArray;                                       // 0x01C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IteratingEnable;                                   // 0x01D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1[0x3];                                      // 0x01D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentIndex;                                      // 0x01D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D8[0x8];                                      // 0x01D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddLinkedAsset(class UAnimVariationSet_DN* LinkedVariationSet);
	class UAnimationAsset* GetAnimationUsingCurIndex();
	void InvalidateCurrentIndex();
	bool IsCurrentIndexValid(EBranchesOutEnum* Branches);
	bool SetCurrentIndex(int32 InCurrentIndex, bool ChangeAnimInRuntime, int32 RepeatCount);
	bool SetCurrentIndexOnlyIfCurrentNotValid(int32 InCurrentIndex, bool ChangeAnimInRuntime, int32 RepeatCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimVariationSet_DN">();
	}
	static class UAnimVariationSet_DN* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimVariationSet_DN>();
	}
};
static_assert(alignof(UAnimVariationSet_DN) == 0x000008, "Wrong alignment on UAnimVariationSet_DN");
static_assert(sizeof(UAnimVariationSet_DN) == 0x0001E0, "Wrong size on UAnimVariationSet_DN");
static_assert(offsetof(UAnimVariationSet_DN, AnimSequenceArray) == 0x0001B0, "Member 'UAnimVariationSet_DN::AnimSequenceArray' has a wrong offset!");
static_assert(offsetof(UAnimVariationSet_DN, LinkedArray) == 0x0001C0, "Member 'UAnimVariationSet_DN::LinkedArray' has a wrong offset!");
static_assert(offsetof(UAnimVariationSet_DN, IteratingEnable) == 0x0001D0, "Member 'UAnimVariationSet_DN::IteratingEnable' has a wrong offset!");
static_assert(offsetof(UAnimVariationSet_DN, CurrentIndex) == 0x0001D4, "Member 'UAnimVariationSet_DN::CurrentIndex' has a wrong offset!");

// Class DynamicNode.DNMovementComponent
// 0x0390 (0x0E90 - 0x0B00)
class UDNMovementComponent final : public UCharacterMovementComponent
{
public:
	bool                                          bCanJumpOutOfWater;                                // 0x0B00(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B01[0x3];                                      // 0x0B01(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpOutOfWaterMaxImpersionDepth;                   // 0x0B04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpOutOfWaterZVelocity;                           // 0x0B08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ComputeJumpZVelocityUsingImpersionDepth;           // 0x0B0C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0D[0x3];                                      // 0x0B0D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpZVelocityImpersionDepthCoef;                   // 0x0B10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseShrinkCapsuleForSwimming;                       // 0x0B14(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B15[0x3];                                      // 0x0B15(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SwimmHalfHeight;                                   // 0x0B18(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSurfaceSwimmSpeed;                              // 0x0B1C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurfaceSwimmDepth;                                 // 0x0B20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B24[0x4];                                      // 0x0B24(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SurfaceSwimmDepthUpperLimit;                       // 0x0B28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurfaceSwimmDepthBottomLimit;                      // 0x0B2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingZVelocityThreshold;                         // 0x0B30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimmingZAccVectorThreshold;                       // 0x0B34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwimmingZVelocityThreshold;                        // 0x0B38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSurSwimmZAccVectorThreshold_Dive;               // 0x0B3C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B3D[0x3];                                      // 0x0B3D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SurSwimmZAccVectorThreshold_Dive;                  // 0x0B40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOfWaterZAccVectorThreshold;                     // 0x0B44(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOfWaterDepthThreshold_UP;                       // 0x0B48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOfWaterDepthThreshold_BOT;                      // 0x0B4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOfWaterDepthDifThreshold_Min;                   // 0x0B50(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOfWaterDepthDifThreshold_Max;                   // 0x0B54(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOfWaterAccelerationPower;                       // 0x0B58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOfWaterMaxAccelerationZ;                        // 0x0B5C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOfWaterAddVelocity;                             // 0x0B60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshBlendSpeed;                                    // 0x0B64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveSpeed;                                         // 0x0B68(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveAmplitude;                                     // 0x0B6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveAmplitudeFactorWhenMoving;                     // 0x0B70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveAmplitudeFactorWhenMoving_VelocityThreshold;   // 0x0B74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaveZVelLimit;                                     // 0x0B78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZVelLimitFriction;                                 // 0x0B7C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurfaceSwimmBorderForceLinearMultiplier;           // 0x0B80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurfaceSwimmBorderForceMultiplier;                 // 0x0B84(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WaveShowDebug;                                     // 0x0B88(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseVelocityToOrientToMovementRotation;             // 0x0B89(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseNonLinearRotationRate;                          // 0x0B8A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseRotationRateDependingOnSpeed;                   // 0x0B8B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationRateDependingOnSpeedMinCoef;               // 0x0B8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationRateDependingOnSpeedMaxSpeed;              // 0x0B90(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotatingFactorThreshold;                           // 0x0B94(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotatingFactorMulti;                               // 0x0B98(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeedFactorWhenRotating;                        // 0x0B9C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MaxSpeedFactorWhenRotatingUseCurve;                // 0x0BA0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA1[0x7];                                      // 0x0BA1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MaxSpeedFactorWhenRotatingCurve;                   // 0x0BA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationFactorWhenRotating;                    // 0x0BB0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrictionFactorWhenRotating;                        // 0x0BB4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOrientRotationToMovement_UseReverse;              // 0x0BB8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB9[0x3];                                      // 0x0BB9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OrientRotationToMovement_ReverseDotValue;          // 0x0BBC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSoftAccelereationInput;                         // 0x0BC0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC1[0x3];                                      // 0x0BC1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SoftAccelereationThresholdAngle;                   // 0x0BC4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoftAccelereationInputMaxAngle;                    // 0x0BC8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoftAccelereationInputOutMin;                      // 0x0BCC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoftAccelereationInputOutMax;                      // 0x0BD0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoftAccelereationInputAlignTimeSec_ForUseReverse;  // 0x0BD4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoftAccelereationInputAlignDotThreshold_ForUseReverse; // 0x0BD8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseMovementComponentForSwimmMachineState;          // 0x0BDC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseMovementComponentForImpactState;                // 0x0BDD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BDE[0x2];                                      // 0x0BDE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpactVelocityThreshold;                           // 0x0BE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactDotThreshold;                                // 0x0BE4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseControllerDesiredRotationSpecifiedAngle;       // 0x0BE8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CDRSpecifiedAngleLimitRotation;                    // 0x0BE9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CDRSpecifiedAngleCanChangeDirDuringRotation;       // 0x0BEA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BEB[0x1];                                      // 0x0BEB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CDRSpecifiedAngleCameraSpeedThreshold;             // 0x0BEC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CDRSpecifiedAngleTimerAfterRotation;               // 0x0BF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CDRSpecifiedAngleTimerAfterMoving;                 // 0x0BF4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CDRSpecifiedAngleTimerAfterMoving_UseTurnWithoutAnims; // 0x0BF8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BF9[0x3];                                      // 0x0BF9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CDRSpecifiedAngleTimerAfterMoving_RotationRateYaw; // 0x0BFC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CDRSpecifiedAngleStanding;                         // 0x0C00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CDRSpecifiedAngleUse2Angles;                       // 0x0C04(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C05[0x3];                                      // 0x0C05(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CDRSpecifiedAngleStanding_2;                       // 0x0C08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CDRSpecifiedAngleMoving;                           // 0x0C0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CDRSpecifiedAngleRotationRateYaw;                  // 0x0C10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CDRSpecifiedAngleRotationRateYaw_2;                // 0x0C14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceVelocityThreshold;                      // 0x0C18(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnVelocityThreshold;                             // 0x0C1C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnInPlaceAdditionalAnimTransitionTime;           // 0x0C20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TurnInPlaceUseOnlyNOTMultiTransitionToMoveFromIdle; // 0x0C24(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RequestedMoveAlwaysUseAcceleration;                // 0x0C25(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C26[0x1A];                                     // 0x0C26(0x001A)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StoppingAnimationTimer;                            // 0x0C40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStoppingAnimProcType_DN                      StoppingAnimationProccType;                        // 0x0C44(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMeshForwardAxis_DN                           MeshForwardAxis;                                   // 0x0C45(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MaxSpeedCurveCanExceed_1;                          // 0x0C46(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanProne;                                          // 0x0C47(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanProneWhenCrouching;                             // 0x0C48(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanCrouchWhenProne;                                // 0x0C49(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanSlideWhenProne;                                 // 0x0C4A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4B[0x1];                                      // 0x0C4B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProneHalfHeight;                                   // 0x0C4C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bCanWalkOffLedgesWhenProne : 1;                    // 0x0C50(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C51[0x3];                                      // 0x0C51(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxWalkSpeedProne;                                 // 0x0C54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProneMaintainsBaseLocation;                       // 0x0C58(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C59[0x3];                                      // 0x0C59(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bWantsToProne : 1;                                 // 0x0C5C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bWantsToShrink : 1;                                // 0x0C5C(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C5D[0x233];                                    // 0x0C5D(0x0233)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlockMovement(bool Enabled, bool bLockRotation);
	void Dive();
	void FindAndAdjustFloor(float Timer, float Speed);
	float GetLastYawDelta();
	float GetLastYawDeltaAbs();
	float GetLastYawDir();
	bool GetSurfaceSwimmingStatus();
	bool IsSurfaceStatus();
	bool IsSurfaceSwimming();
	bool IsUnderwaterStatus();
	bool IsUnderwaterSwimming();
	void RemoveRotationSoft(const struct FRotator& RemoveRotation, float TransitionTime, float FinalRotationTolerance);
	void ResetDesiredRotation();
	void RotateUpdatedComponentSoft(const struct FRotator& NewActorRotation, float TransitionTime, float FinalRotationTolerance);
	void SetAdjustFloorHeightSpeed(float Timer, float Speed);
	void SetDesiredRotationOffset_PropsActor(float LeftMove, float RightMove, const TDelegate<void(bool IsCompleted)>& DesiredRotateComplete, float AddOffsetAngle, float AutoResetIfVelocityExceed, bool TryToUseTurnInPlace);
	void SetDesiredRotationOffsetYaw(float OffsetYaw, float AutoResetIfVelocityExceed, bool TryToUseTurnInPlace);
	void SetDesiredRotationOffsetYaw_Delegate(float OffsetYaw, const TDelegate<void(bool IsCompleted)>& DesiredRotateComplete, float AutoResetIfVelocityExceed, bool TryToUseTurnInPlace);
	void SetDesiredRotationYaw(float DesiredRotationYaw, float AutoResetIfVelocityExceed, bool TryToUseTurnInPlace);
	void SetDesiredRotationYaw_Delegate(float DesiredRotationYaw, const TDelegate<void(bool IsCompleted)>& DesiredRotateComplete, float AutoResetIfVelocityExceed, bool TryToUseTurnInPlace);
	void SetMaxWalkSpeed(float NewMovementSpeed, float TransitionTime);
	void SetPauseForControllerDesiredRotationSpecifiedAngle(bool Pause);
	void SetSurfaceSwimmingStatus(bool NewStatus);
	void Surface();

	float GetOrientRotationToMovement_Reverse_LastDotValue() const;
	bool IsMovementBlocked() const;
	bool IsProne() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DNMovementComponent">();
	}
	static class UDNMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDNMovementComponent>();
	}
};
static_assert(alignof(UDNMovementComponent) == 0x000010, "Wrong alignment on UDNMovementComponent");
static_assert(sizeof(UDNMovementComponent) == 0x000E90, "Wrong size on UDNMovementComponent");
static_assert(offsetof(UDNMovementComponent, bCanJumpOutOfWater) == 0x000B00, "Member 'UDNMovementComponent::bCanJumpOutOfWater' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, JumpOutOfWaterMaxImpersionDepth) == 0x000B04, "Member 'UDNMovementComponent::JumpOutOfWaterMaxImpersionDepth' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, JumpOutOfWaterZVelocity) == 0x000B08, "Member 'UDNMovementComponent::JumpOutOfWaterZVelocity' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, ComputeJumpZVelocityUsingImpersionDepth) == 0x000B0C, "Member 'UDNMovementComponent::ComputeJumpZVelocityUsingImpersionDepth' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, JumpZVelocityImpersionDepthCoef) == 0x000B10, "Member 'UDNMovementComponent::JumpZVelocityImpersionDepthCoef' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, UseShrinkCapsuleForSwimming) == 0x000B14, "Member 'UDNMovementComponent::UseShrinkCapsuleForSwimming' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, SwimmHalfHeight) == 0x000B18, "Member 'UDNMovementComponent::SwimmHalfHeight' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, MaxSurfaceSwimmSpeed) == 0x000B1C, "Member 'UDNMovementComponent::MaxSurfaceSwimmSpeed' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, SurfaceSwimmDepth) == 0x000B20, "Member 'UDNMovementComponent::SurfaceSwimmDepth' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, SurfaceSwimmDepthUpperLimit) == 0x000B28, "Member 'UDNMovementComponent::SurfaceSwimmDepthUpperLimit' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, SurfaceSwimmDepthBottomLimit) == 0x000B2C, "Member 'UDNMovementComponent::SurfaceSwimmDepthBottomLimit' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, FallingZVelocityThreshold) == 0x000B30, "Member 'UDNMovementComponent::FallingZVelocityThreshold' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, SwimmingZAccVectorThreshold) == 0x000B34, "Member 'UDNMovementComponent::SwimmingZAccVectorThreshold' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, SwimmingZVelocityThreshold) == 0x000B38, "Member 'UDNMovementComponent::SwimmingZVelocityThreshold' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, UseSurSwimmZAccVectorThreshold_Dive) == 0x000B3C, "Member 'UDNMovementComponent::UseSurSwimmZAccVectorThreshold_Dive' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, SurSwimmZAccVectorThreshold_Dive) == 0x000B40, "Member 'UDNMovementComponent::SurSwimmZAccVectorThreshold_Dive' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, OutOfWaterZAccVectorThreshold) == 0x000B44, "Member 'UDNMovementComponent::OutOfWaterZAccVectorThreshold' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, OutOfWaterDepthThreshold_UP) == 0x000B48, "Member 'UDNMovementComponent::OutOfWaterDepthThreshold_UP' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, OutOfWaterDepthThreshold_BOT) == 0x000B4C, "Member 'UDNMovementComponent::OutOfWaterDepthThreshold_BOT' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, OutOfWaterDepthDifThreshold_Min) == 0x000B50, "Member 'UDNMovementComponent::OutOfWaterDepthDifThreshold_Min' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, OutOfWaterDepthDifThreshold_Max) == 0x000B54, "Member 'UDNMovementComponent::OutOfWaterDepthDifThreshold_Max' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, OutOfWaterAccelerationPower) == 0x000B58, "Member 'UDNMovementComponent::OutOfWaterAccelerationPower' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, OutOfWaterMaxAccelerationZ) == 0x000B5C, "Member 'UDNMovementComponent::OutOfWaterMaxAccelerationZ' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, OutOfWaterAddVelocity) == 0x000B60, "Member 'UDNMovementComponent::OutOfWaterAddVelocity' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, MeshBlendSpeed) == 0x000B64, "Member 'UDNMovementComponent::MeshBlendSpeed' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, WaveSpeed) == 0x000B68, "Member 'UDNMovementComponent::WaveSpeed' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, WaveAmplitude) == 0x000B6C, "Member 'UDNMovementComponent::WaveAmplitude' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, WaveAmplitudeFactorWhenMoving) == 0x000B70, "Member 'UDNMovementComponent::WaveAmplitudeFactorWhenMoving' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, WaveAmplitudeFactorWhenMoving_VelocityThreshold) == 0x000B74, "Member 'UDNMovementComponent::WaveAmplitudeFactorWhenMoving_VelocityThreshold' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, WaveZVelLimit) == 0x000B78, "Member 'UDNMovementComponent::WaveZVelLimit' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, ZVelLimitFriction) == 0x000B7C, "Member 'UDNMovementComponent::ZVelLimitFriction' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, SurfaceSwimmBorderForceLinearMultiplier) == 0x000B80, "Member 'UDNMovementComponent::SurfaceSwimmBorderForceLinearMultiplier' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, SurfaceSwimmBorderForceMultiplier) == 0x000B84, "Member 'UDNMovementComponent::SurfaceSwimmBorderForceMultiplier' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, WaveShowDebug) == 0x000B88, "Member 'UDNMovementComponent::WaveShowDebug' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, UseVelocityToOrientToMovementRotation) == 0x000B89, "Member 'UDNMovementComponent::UseVelocityToOrientToMovementRotation' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, UseNonLinearRotationRate) == 0x000B8A, "Member 'UDNMovementComponent::UseNonLinearRotationRate' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, UseRotationRateDependingOnSpeed) == 0x000B8B, "Member 'UDNMovementComponent::UseRotationRateDependingOnSpeed' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, RotationRateDependingOnSpeedMinCoef) == 0x000B8C, "Member 'UDNMovementComponent::RotationRateDependingOnSpeedMinCoef' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, RotationRateDependingOnSpeedMaxSpeed) == 0x000B90, "Member 'UDNMovementComponent::RotationRateDependingOnSpeedMaxSpeed' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, RotatingFactorThreshold) == 0x000B94, "Member 'UDNMovementComponent::RotatingFactorThreshold' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, RotatingFactorMulti) == 0x000B98, "Member 'UDNMovementComponent::RotatingFactorMulti' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, MaxSpeedFactorWhenRotating) == 0x000B9C, "Member 'UDNMovementComponent::MaxSpeedFactorWhenRotating' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, MaxSpeedFactorWhenRotatingUseCurve) == 0x000BA0, "Member 'UDNMovementComponent::MaxSpeedFactorWhenRotatingUseCurve' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, MaxSpeedFactorWhenRotatingCurve) == 0x000BA8, "Member 'UDNMovementComponent::MaxSpeedFactorWhenRotatingCurve' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, AccelerationFactorWhenRotating) == 0x000BB0, "Member 'UDNMovementComponent::AccelerationFactorWhenRotating' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, FrictionFactorWhenRotating) == 0x000BB4, "Member 'UDNMovementComponent::FrictionFactorWhenRotating' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, bOrientRotationToMovement_UseReverse) == 0x000BB8, "Member 'UDNMovementComponent::bOrientRotationToMovement_UseReverse' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, OrientRotationToMovement_ReverseDotValue) == 0x000BBC, "Member 'UDNMovementComponent::OrientRotationToMovement_ReverseDotValue' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, UseSoftAccelereationInput) == 0x000BC0, "Member 'UDNMovementComponent::UseSoftAccelereationInput' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, SoftAccelereationThresholdAngle) == 0x000BC4, "Member 'UDNMovementComponent::SoftAccelereationThresholdAngle' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, SoftAccelereationInputMaxAngle) == 0x000BC8, "Member 'UDNMovementComponent::SoftAccelereationInputMaxAngle' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, SoftAccelereationInputOutMin) == 0x000BCC, "Member 'UDNMovementComponent::SoftAccelereationInputOutMin' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, SoftAccelereationInputOutMax) == 0x000BD0, "Member 'UDNMovementComponent::SoftAccelereationInputOutMax' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, SoftAccelereationInputAlignTimeSec_ForUseReverse) == 0x000BD4, "Member 'UDNMovementComponent::SoftAccelereationInputAlignTimeSec_ForUseReverse' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, SoftAccelereationInputAlignDotThreshold_ForUseReverse) == 0x000BD8, "Member 'UDNMovementComponent::SoftAccelereationInputAlignDotThreshold_ForUseReverse' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, UseMovementComponentForSwimmMachineState) == 0x000BDC, "Member 'UDNMovementComponent::UseMovementComponentForSwimmMachineState' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, UseMovementComponentForImpactState) == 0x000BDD, "Member 'UDNMovementComponent::UseMovementComponentForImpactState' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, ImpactVelocityThreshold) == 0x000BE0, "Member 'UDNMovementComponent::ImpactVelocityThreshold' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, ImpactDotThreshold) == 0x000BE4, "Member 'UDNMovementComponent::ImpactDotThreshold' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, bUseControllerDesiredRotationSpecifiedAngle) == 0x000BE8, "Member 'UDNMovementComponent::bUseControllerDesiredRotationSpecifiedAngle' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, CDRSpecifiedAngleLimitRotation) == 0x000BE9, "Member 'UDNMovementComponent::CDRSpecifiedAngleLimitRotation' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, CDRSpecifiedAngleCanChangeDirDuringRotation) == 0x000BEA, "Member 'UDNMovementComponent::CDRSpecifiedAngleCanChangeDirDuringRotation' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, CDRSpecifiedAngleCameraSpeedThreshold) == 0x000BEC, "Member 'UDNMovementComponent::CDRSpecifiedAngleCameraSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, CDRSpecifiedAngleTimerAfterRotation) == 0x000BF0, "Member 'UDNMovementComponent::CDRSpecifiedAngleTimerAfterRotation' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, CDRSpecifiedAngleTimerAfterMoving) == 0x000BF4, "Member 'UDNMovementComponent::CDRSpecifiedAngleTimerAfterMoving' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, CDRSpecifiedAngleTimerAfterMoving_UseTurnWithoutAnims) == 0x000BF8, "Member 'UDNMovementComponent::CDRSpecifiedAngleTimerAfterMoving_UseTurnWithoutAnims' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, CDRSpecifiedAngleTimerAfterMoving_RotationRateYaw) == 0x000BFC, "Member 'UDNMovementComponent::CDRSpecifiedAngleTimerAfterMoving_RotationRateYaw' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, CDRSpecifiedAngleStanding) == 0x000C00, "Member 'UDNMovementComponent::CDRSpecifiedAngleStanding' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, CDRSpecifiedAngleUse2Angles) == 0x000C04, "Member 'UDNMovementComponent::CDRSpecifiedAngleUse2Angles' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, CDRSpecifiedAngleStanding_2) == 0x000C08, "Member 'UDNMovementComponent::CDRSpecifiedAngleStanding_2' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, CDRSpecifiedAngleMoving) == 0x000C0C, "Member 'UDNMovementComponent::CDRSpecifiedAngleMoving' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, CDRSpecifiedAngleRotationRateYaw) == 0x000C10, "Member 'UDNMovementComponent::CDRSpecifiedAngleRotationRateYaw' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, CDRSpecifiedAngleRotationRateYaw_2) == 0x000C14, "Member 'UDNMovementComponent::CDRSpecifiedAngleRotationRateYaw_2' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, TurnInPlaceVelocityThreshold) == 0x000C18, "Member 'UDNMovementComponent::TurnInPlaceVelocityThreshold' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, TurnVelocityThreshold) == 0x000C1C, "Member 'UDNMovementComponent::TurnVelocityThreshold' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, TurnInPlaceAdditionalAnimTransitionTime) == 0x000C20, "Member 'UDNMovementComponent::TurnInPlaceAdditionalAnimTransitionTime' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, TurnInPlaceUseOnlyNOTMultiTransitionToMoveFromIdle) == 0x000C24, "Member 'UDNMovementComponent::TurnInPlaceUseOnlyNOTMultiTransitionToMoveFromIdle' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, RequestedMoveAlwaysUseAcceleration) == 0x000C25, "Member 'UDNMovementComponent::RequestedMoveAlwaysUseAcceleration' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, StoppingAnimationTimer) == 0x000C40, "Member 'UDNMovementComponent::StoppingAnimationTimer' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, StoppingAnimationProccType) == 0x000C44, "Member 'UDNMovementComponent::StoppingAnimationProccType' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, MeshForwardAxis) == 0x000C45, "Member 'UDNMovementComponent::MeshForwardAxis' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, MaxSpeedCurveCanExceed_1) == 0x000C46, "Member 'UDNMovementComponent::MaxSpeedCurveCanExceed_1' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, CanProne) == 0x000C47, "Member 'UDNMovementComponent::CanProne' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, CanProneWhenCrouching) == 0x000C48, "Member 'UDNMovementComponent::CanProneWhenCrouching' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, CanCrouchWhenProne) == 0x000C49, "Member 'UDNMovementComponent::CanCrouchWhenProne' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, CanSlideWhenProne) == 0x000C4A, "Member 'UDNMovementComponent::CanSlideWhenProne' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, ProneHalfHeight) == 0x000C4C, "Member 'UDNMovementComponent::ProneHalfHeight' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, MaxWalkSpeedProne) == 0x000C54, "Member 'UDNMovementComponent::MaxWalkSpeedProne' has a wrong offset!");
static_assert(offsetof(UDNMovementComponent, bProneMaintainsBaseLocation) == 0x000C58, "Member 'UDNMovementComponent::bProneMaintainsBaseLocation' has a wrong offset!");

// Class DynamicNode.DNCharacter
// 0x0100 (0x05C0 - 0x04C0)
class ADNCharacter : public ACharacter
{
public:
	float                                         SoftFaceRotationSpeed;                             // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4BC[0xC];                                      // 0x04BC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          UseControllerRotationOnlyWhenMoving;               // 0x04C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseControllerRotationOnlyWhenStanding;             // 0x04C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4CA[0x6];                                      // 0x04CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLegsPhysicalSurface_DN>        LegsPhysicalSurface;                               // 0x04D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	bool                                          UseCustomMovementReplicationWhenUsingControllerRotation; // 0x04E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E1[0x3];                                      // 0x04E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UseCustomMovementReplicationIntRotationSpeed;      // 0x04E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReplicationType_DN                           PivotMachineReplicationType;                       // 0x04E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReplicationType_DN                           ImpactMachineReplicationType;                      // 0x04E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4EA[0x2];                                      // 0x04EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProneEyeHeight;                                    // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpTopPosition;                                   // 0x04F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastFallHeight;                                    // 0x04F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawDebug;                                         // 0x04F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F9[0x3];                                      // 0x04F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsProne : 1;                                      // 0x04FC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsShrink : 1;                                     // 0x04FC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4FD[0x3];                                      // 0x04FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         ReplicatedSurfaceSwimmMode;                        // 0x0500(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_501[0x3];                                      // 0x0501(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxAccelerationCoef;                               // 0x0504(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FrictionFactorChangeDir;                           // 0x0508(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpeedRotationCoef;                              // 0x050C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentAngleDeltaAbs;                              // 0x0510(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentAngleDir;                                   // 0x0514(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_518[0xC];                                      // 0x0518(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseOverrideFaceRotation;                          // 0x0524(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_525[0x33];                                     // 0x0525(0x0033)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize100                 ControllerInputVector;                             // 0x0558(0x000C)(Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               NewControlRotation_TAR;                            // 0x0564(0x000C)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_570[0x24];                                     // 0x0570(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         UsingCustomMovementReplication;                    // 0x0594(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_595[0x2B];                                     // 0x0595(0x002B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AllEquipThingReady();
	void DisableControllerRotation();
	void EndProne(bool bClientSimulation);
	void GetFirstPropsActor(EBranchesOutEnum* Branches, class AActionPropsActor_DN** PropsActor, class FName* ActorType, class FName* InstanceName);
	class UPhysicalMaterial* GetLastLeftLegPhysicalMaterial(EBranchesOutEnum* Branches, bool* IsValid, int32 LegIndex);
	EPhysicalSurface GetLastLeftLegPhysicalSurface(EBranchesOutEnum* Branches, bool* IsValid, int32 LegIndex, bool ReturnDefaultSurfaceIfNotFinded, EPhysicalSurface DefaultSurface);
	class UPhysicalMaterial* GetLastRightLegPhysicalMaterial(EBranchesOutEnum* Branches, bool* IsValid, int32 LegIndex);
	EPhysicalSurface GetLastRightLegPhysicalSurface(EBranchesOutEnum* Branches, bool* IsValid, int32 LegIndex, bool ReturnDefaultSurfaceIfNotFinded, EPhysicalSurface DefaultSurface);
	void GetNearestPropsActor(EBranchesOutEnum* Branches, class AActionPropsActor_DN** PropsActor, class FName* ActorType, class FName* InstanceName);
	TArray<class AActionPropsActor_DN*> GetNearestPropsActors(EBranchesOutEnum* Branches);
	void K2_OnBaseChange(class UPrimitiveComponent* PrimitiveComponent, class AActor* OutActor);
	void K2_OnEndProne(float HalfHeightAdjust, float ScaledHalfHeightAdjust);
	void K2_OnStartProne(float HalfHeightAdjust, float ScaledHalfHeightAdjust, bool FromCrouch);
	void OnEndImpact(class UAnimationAsset* PivotAnimation);
	void OnEndPivot(class UAnimationAsset* PivotAnimation);
	void OnEndSwimming();
	void OnPivot(class UAnimationAsset* PivotAnimation);
	void OnRep_IsProne();
	void OnRep_IsShrink();
	void OnRep_NewControlRotation();
	void OnStartAutoCrouching();
	void OnStartFallingFromTopPosition();
	void OnStartInAir();
	void OnStartStanding();
	void OnStartSwimming();
	void OverrideFaceRotation(const struct FRotator& OverrideRotation, bool Enable);
	void SERVER_ComputeLocallyVariables(const struct FLocallyRepData_DN_Int& RepData);
	void SetAutoCrouching(bool Enabled, float CapsuleAddHeight, float AddRadius, float CapsuleZOffset, float CapsuleForwardOffset, const struct FRotator& CapsuleRotation, float InTimer, float OutTimer, bool Param_DrawDebug, float DrawDebugTimer, bool DrawDebugOnlySuccAttempts);
	void SetControllerRotationParams(bool UseControllerRotationPitch, bool UseControllerRotationYaw, bool UseControllerRotationRoll, float StartSoftFaceRotationTime, float FinSoftFaceRotationTime, float TransitionTimeBetweenStartAndFin);
	void SetDampingMultiAllBodyBellow(float AngularDampingFactor, float LinearDampingFactor, class FName BoneName);
	void SetEnableGravityAllBodyBellow(bool Enabled, class FName BoneName);
	void SetMaxSpeedFactor(float Factor);
	void SetOverrideViewRotation(bool Enabled, const struct FRotator& OverideRotation);
	void SetReplicatedInputVector_AP(const struct FVector& InControllerInputVector);
	void SetTimerAutoCrouching(float TimerVal);
	void SPROXY_ComputeLocallyVariables(const struct FLocallyRepData_DN_Int& RepData);
	void StartProne(bool bClientSimulation);

	float GetCurrentMaxSpeed(bool UseMaxSpeedFactor) const;
	class UDNMovementComponent* GetDNMovementComponent() const;
	float GetMaxSpeedFactor() const;
	float GetReplicatedCurrentAngleDeltaAbs() const;
	float GetReplicatedCurrentAngleDir() const;
	float GetReplicatedFrictionFactorChangeDir() const;
	float GetReplicatedMaxAccelerationCoef() const;
	float GetReplicatedMaxSpeedCoef() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DNCharacter">();
	}
	static class ADNCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADNCharacter>();
	}
};
static_assert(alignof(ADNCharacter) == 0x000010, "Wrong alignment on ADNCharacter");
static_assert(sizeof(ADNCharacter) == 0x0005C0, "Wrong size on ADNCharacter");
static_assert(offsetof(ADNCharacter, SoftFaceRotationSpeed) == 0x0004B8, "Member 'ADNCharacter::SoftFaceRotationSpeed' has a wrong offset!");
static_assert(offsetof(ADNCharacter, UseControllerRotationOnlyWhenMoving) == 0x0004C8, "Member 'ADNCharacter::UseControllerRotationOnlyWhenMoving' has a wrong offset!");
static_assert(offsetof(ADNCharacter, UseControllerRotationOnlyWhenStanding) == 0x0004C9, "Member 'ADNCharacter::UseControllerRotationOnlyWhenStanding' has a wrong offset!");
static_assert(offsetof(ADNCharacter, LegsPhysicalSurface) == 0x0004D0, "Member 'ADNCharacter::LegsPhysicalSurface' has a wrong offset!");
static_assert(offsetof(ADNCharacter, UseCustomMovementReplicationWhenUsingControllerRotation) == 0x0004E0, "Member 'ADNCharacter::UseCustomMovementReplicationWhenUsingControllerRotation' has a wrong offset!");
static_assert(offsetof(ADNCharacter, UseCustomMovementReplicationIntRotationSpeed) == 0x0004E4, "Member 'ADNCharacter::UseCustomMovementReplicationIntRotationSpeed' has a wrong offset!");
static_assert(offsetof(ADNCharacter, PivotMachineReplicationType) == 0x0004E8, "Member 'ADNCharacter::PivotMachineReplicationType' has a wrong offset!");
static_assert(offsetof(ADNCharacter, ImpactMachineReplicationType) == 0x0004E9, "Member 'ADNCharacter::ImpactMachineReplicationType' has a wrong offset!");
static_assert(offsetof(ADNCharacter, ProneEyeHeight) == 0x0004EC, "Member 'ADNCharacter::ProneEyeHeight' has a wrong offset!");
static_assert(offsetof(ADNCharacter, JumpTopPosition) == 0x0004F0, "Member 'ADNCharacter::JumpTopPosition' has a wrong offset!");
static_assert(offsetof(ADNCharacter, LastFallHeight) == 0x0004F4, "Member 'ADNCharacter::LastFallHeight' has a wrong offset!");
static_assert(offsetof(ADNCharacter, DrawDebug) == 0x0004F8, "Member 'ADNCharacter::DrawDebug' has a wrong offset!");
static_assert(offsetof(ADNCharacter, ReplicatedSurfaceSwimmMode) == 0x000500, "Member 'ADNCharacter::ReplicatedSurfaceSwimmMode' has a wrong offset!");
static_assert(offsetof(ADNCharacter, MaxAccelerationCoef) == 0x000504, "Member 'ADNCharacter::MaxAccelerationCoef' has a wrong offset!");
static_assert(offsetof(ADNCharacter, FrictionFactorChangeDir) == 0x000508, "Member 'ADNCharacter::FrictionFactorChangeDir' has a wrong offset!");
static_assert(offsetof(ADNCharacter, MaxSpeedRotationCoef) == 0x00050C, "Member 'ADNCharacter::MaxSpeedRotationCoef' has a wrong offset!");
static_assert(offsetof(ADNCharacter, CurrentAngleDeltaAbs) == 0x000510, "Member 'ADNCharacter::CurrentAngleDeltaAbs' has a wrong offset!");
static_assert(offsetof(ADNCharacter, CurrentAngleDir) == 0x000514, "Member 'ADNCharacter::CurrentAngleDir' has a wrong offset!");
static_assert(offsetof(ADNCharacter, bUseOverrideFaceRotation) == 0x000524, "Member 'ADNCharacter::bUseOverrideFaceRotation' has a wrong offset!");
static_assert(offsetof(ADNCharacter, ControllerInputVector) == 0x000558, "Member 'ADNCharacter::ControllerInputVector' has a wrong offset!");
static_assert(offsetof(ADNCharacter, NewControlRotation_TAR) == 0x000564, "Member 'ADNCharacter::NewControlRotation_TAR' has a wrong offset!");
static_assert(offsetof(ADNCharacter, UsingCustomMovementReplication) == 0x000594, "Member 'ADNCharacter::UsingCustomMovementReplication' has a wrong offset!");

// Class DynamicNode.AIController_DN
// 0x0000 (0x0328 - 0x0328)
class AAIController_DN final : public AAIController
{
public:
	void StopActiveMovement();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIController_DN">();
	}
	static class AAIController_DN* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIController_DN>();
	}
};
static_assert(alignof(AAIController_DN) == 0x000008, "Wrong alignment on AAIController_DN");
static_assert(sizeof(AAIController_DN) == 0x000328, "Wrong size on AAIController_DN");

// Class DynamicNode.TransitionZone_DN
// 0x0020 (0x0278 - 0x0258)
class ATransitionZone_DN final : public AVolume
{
public:
	class FName                                   ZoneType;                                          // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeInZoneToStartPlay;                          // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinTimeToPlay;                                     // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C[0xC];                                      // 0x026C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransitionZone_DN">();
	}
	static class ATransitionZone_DN* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATransitionZone_DN>();
	}
};
static_assert(alignof(ATransitionZone_DN) == 0x000008, "Wrong alignment on ATransitionZone_DN");
static_assert(sizeof(ATransitionZone_DN) == 0x000278, "Wrong size on ATransitionZone_DN");
static_assert(offsetof(ATransitionZone_DN, ZoneType) == 0x000258, "Member 'ATransitionZone_DN::ZoneType' has a wrong offset!");
static_assert(offsetof(ATransitionZone_DN, Priority) == 0x000260, "Member 'ATransitionZone_DN::Priority' has a wrong offset!");
static_assert(offsetof(ATransitionZone_DN, MinTimeInZoneToStartPlay) == 0x000264, "Member 'ATransitionZone_DN::MinTimeInZoneToStartPlay' has a wrong offset!");
static_assert(offsetof(ATransitionZone_DN, MinTimeToPlay) == 0x000268, "Member 'ATransitionZone_DN::MinTimeToPlay' has a wrong offset!");

// Class DynamicNode.HandleComponent_DN
// 0x0090 (0x0560 - 0x04D0)
class UHandleComponent_DN final : public UStaticMeshComponent
{
public:
	EHandleType_DN                                HandleType;                                        // 0x04D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseHandleType;                                     // 0x04D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D2[0x2];                                      // 0x04D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HandTranslation;                                   // 0x04D4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               HandRotation;                                      // 0x04E0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          SaveHandleType;                                    // 0x04EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ResetHandleType;                                   // 0x04ED(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4EE[0x2];                                      // 0x04EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHandsCCDIKHandleDataH_DN              HandleDataForwardStart;                            // 0x04F0(0x001C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FHandsCCDIKHandleDataH_DN              HandleDataForwardFinal;                            // 0x050C(0x001C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FHandsCCDIKHandleDataH_DN              HandleDataReverseStart;                            // 0x0528(0x001C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FHandsCCDIKHandleDataH_DN              HandleDataReverseFinal;                            // 0x0544(0x001C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HandleComponent_DN">();
	}
	static class UHandleComponent_DN* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHandleComponent_DN>();
	}
};
static_assert(alignof(UHandleComponent_DN) == 0x000010, "Wrong alignment on UHandleComponent_DN");
static_assert(sizeof(UHandleComponent_DN) == 0x000560, "Wrong size on UHandleComponent_DN");
static_assert(offsetof(UHandleComponent_DN, HandleType) == 0x0004D0, "Member 'UHandleComponent_DN::HandleType' has a wrong offset!");
static_assert(offsetof(UHandleComponent_DN, UseHandleType) == 0x0004D1, "Member 'UHandleComponent_DN::UseHandleType' has a wrong offset!");
static_assert(offsetof(UHandleComponent_DN, HandTranslation) == 0x0004D4, "Member 'UHandleComponent_DN::HandTranslation' has a wrong offset!");
static_assert(offsetof(UHandleComponent_DN, HandRotation) == 0x0004E0, "Member 'UHandleComponent_DN::HandRotation' has a wrong offset!");
static_assert(offsetof(UHandleComponent_DN, SaveHandleType) == 0x0004EC, "Member 'UHandleComponent_DN::SaveHandleType' has a wrong offset!");
static_assert(offsetof(UHandleComponent_DN, ResetHandleType) == 0x0004ED, "Member 'UHandleComponent_DN::ResetHandleType' has a wrong offset!");
static_assert(offsetof(UHandleComponent_DN, HandleDataForwardStart) == 0x0004F0, "Member 'UHandleComponent_DN::HandleDataForwardStart' has a wrong offset!");
static_assert(offsetof(UHandleComponent_DN, HandleDataForwardFinal) == 0x00050C, "Member 'UHandleComponent_DN::HandleDataForwardFinal' has a wrong offset!");
static_assert(offsetof(UHandleComponent_DN, HandleDataReverseStart) == 0x000528, "Member 'UHandleComponent_DN::HandleDataReverseStart' has a wrong offset!");
static_assert(offsetof(UHandleComponent_DN, HandleDataReverseFinal) == 0x000544, "Member 'UHandleComponent_DN::HandleDataReverseFinal' has a wrong offset!");

// Class DynamicNode.ActionPropsActor_DN
// 0x03E0 (0x0600 - 0x0220)
class AActionPropsActor_DN final : public AActor
{
public:
	class UBoxComponent*                          ActorBoundariesBox;                                // 0x0220(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   DesiredPlayerPositionPreviewMesh;                  // 0x0228(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   ActionMeshComponent;                               // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActorType;                                         // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InstanceName;                                      // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FHandsCCDIKTargetHandFollowDataH_DN> TargetHandDataArray;                               // 0x0248(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          SetStartPosition;                                  // 0x0258(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             StartLocalTransform;                               // 0x0260(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FIntermediatePointsData_DN>     IntermediatePointsData;                            // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAddIntermediatePoints_DN>      AdditionalIntermediatePoints;                      // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0xD];                                      // 0x02C0(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          SetTarPosition;                                    // 0x02CD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CE[0x2];                                      // 0x02CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TargetLocalTransform;                              // 0x02D0(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0x38];                                     // 0x0300(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAdditionalTargetPointsData_DN> AdditionalTargetLocalTransform;                    // 0x0338(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandMoveLimitAlpha;                                // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandReverseMoveLimitAlpha;                         // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInterpolationBlend_DN                        InterpolationType;                                 // 0x0354(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ResetHandsAfterFinishMove;                         // 0x0355(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInterruptBehaviorFollowActor_DN              InterruptBehavior;                                 // 0x0356(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInterruptBehaviorFollowActor_DN              InterruptBehaviorReverseMode;                      // 0x0357(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrackingTypeWhenFollow_DN                    TrackingTypeWhenFollow;                            // 0x0358(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_359[0x3];                                      // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TranslationScale;                                  // 0x035C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationScale;                                     // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale3DScale;                                      // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SetToStartPosition;                                // 0x0368(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MoveToStartPosition;                               // 0x0369(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MoveToFinalPosition;                               // 0x036A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36B[0x1];                                      // 0x036B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MoveToFinalPositionIndex;                          // 0x036C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UsingIntermediatePointIndex;                       // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Reverse;                                           // 0x0374(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x0375(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_376[0x28A];                                    // 0x0376(0x028A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class APropsActorZone_DN* CheckPropsActorZoneOverlap(EBranchesOutEnum* Branches, class ACharacter* Charater);
	bool CheckTargetSocketExist(class FName TargetSocketName);
	void DisableIntermediatePoints();
	void EndMoveEvent(bool IsReverse);
	void HandMoveBackEvent(bool IsReverse, float CurTime, const struct FTransform& CurRelativeTransform);
	void HandReachedTargetSocketEvent(int32 HandIdx, bool IsReverse);
	void IntermediatePointsReachedEvent(bool IsReverse, int32 Param_Index);
	void InteruptCurrentMovement(EInterruptBehaviorFollowActor_DN Behavior);
	bool IsDirectMode(EBranchesOutEnum* Branches, int32 FromIndex, int32 ToIndex);
	bool IsInPosition(EBranchesOutEnum* Branches, EPropsActorPosition_DN NewPropsActorPosition, int32 IntermediatePositionIndex, float Tolerance);
	bool IsMoveComplited(EBranchesOutEnum* Branches);
	bool IsNextReverse(EBranchesOutEnum* Branches);
	void ResetDirectModePairs();
	void ResetHandleComponentTargetIndexData();
	void ResetIntermediateTargetIndexData();
	void SetActionMeshRelativeOffsetToActorOffset();
	void SetDirectModePairsBothDirection(int32 FirstIndex, int32 SecondIndex);
	void SetDirectModePairsSingleDirection(int32 FromIndex, int32 ToIndex);
	void SetNextTargetLocation(int32 Param_Index);
	void SetPosition(EPropsActorPosition_DN NewPropsActorPosition, int32 IntermediatePositionIndex, bool MoveFromIntermediateToStartPosition);
	void SetSpecificHandleComponent(class FName TargetSocketName, class FName HandComponentTagName);
	void SetSpecificHandleComponentTargetIndex(const TArray<int32>& TargetIndexArray, class FName TargetSocketName, class FName HandComponentTagName);
	void SetSpecificHandleComponentUsingTargetIndex(int32 TargetIndex);
	void SetSpecificHandleComponentUsingTargetIndexExt(int32 FromIndex, int32 ToIndex);
	void SetSpecificIntermediatePoints(int32 IntermediatePointsIndex);
	void SetSpecificIntermediatePointsUsingTargetIndex(int32 TargetIndex);
	void SetSpecificIntermediateTargetIndex(const TArray<int32>& TargetIndexArray, int32 IntermediatePointIndex);
	void SetSpecificTargetSocket(class FName SpecificTargetSocketName);
	void SetTargetAlpha(float TargetAlpha, bool ChangeDirectionIfNeed);
	void SetTargetAlphaReverse(float TargetAlpha, float TargetAlphaForReverseMode);
	void SetTargetPosition(EPropsActorPosition_DN NewPropsActorPosition, int32 IntermediatePositionIndex);
	void StartHandMoveEvent(int32 HandIdx, bool IsReverse, class FName ToSocketName);
	void StartMoveEvent(bool IsReverse);
	void StartNextFromCurrentLocation();
	void UpdateEvent(float Alpha, float IntermediateAlpha, float CurrentBlendAlpha);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionPropsActor_DN">();
	}
	static class AActionPropsActor_DN* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActionPropsActor_DN>();
	}
};
static_assert(alignof(AActionPropsActor_DN) == 0x000010, "Wrong alignment on AActionPropsActor_DN");
static_assert(sizeof(AActionPropsActor_DN) == 0x000600, "Wrong size on AActionPropsActor_DN");
static_assert(offsetof(AActionPropsActor_DN, ActorBoundariesBox) == 0x000220, "Member 'AActionPropsActor_DN::ActorBoundariesBox' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, DesiredPlayerPositionPreviewMesh) == 0x000228, "Member 'AActionPropsActor_DN::DesiredPlayerPositionPreviewMesh' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, ActionMeshComponent) == 0x000230, "Member 'AActionPropsActor_DN::ActionMeshComponent' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, ActorType) == 0x000238, "Member 'AActionPropsActor_DN::ActorType' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, InstanceName) == 0x000240, "Member 'AActionPropsActor_DN::InstanceName' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, TargetHandDataArray) == 0x000248, "Member 'AActionPropsActor_DN::TargetHandDataArray' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, SetStartPosition) == 0x000258, "Member 'AActionPropsActor_DN::SetStartPosition' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, StartLocalTransform) == 0x000260, "Member 'AActionPropsActor_DN::StartLocalTransform' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, IntermediatePointsData) == 0x000290, "Member 'AActionPropsActor_DN::IntermediatePointsData' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, AdditionalIntermediatePoints) == 0x0002B0, "Member 'AActionPropsActor_DN::AdditionalIntermediatePoints' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, SetTarPosition) == 0x0002CD, "Member 'AActionPropsActor_DN::SetTarPosition' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, TargetLocalTransform) == 0x0002D0, "Member 'AActionPropsActor_DN::TargetLocalTransform' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, AdditionalTargetLocalTransform) == 0x000338, "Member 'AActionPropsActor_DN::AdditionalTargetLocalTransform' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, BlendTime) == 0x000348, "Member 'AActionPropsActor_DN::BlendTime' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, HandMoveLimitAlpha) == 0x00034C, "Member 'AActionPropsActor_DN::HandMoveLimitAlpha' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, HandReverseMoveLimitAlpha) == 0x000350, "Member 'AActionPropsActor_DN::HandReverseMoveLimitAlpha' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, InterpolationType) == 0x000354, "Member 'AActionPropsActor_DN::InterpolationType' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, ResetHandsAfterFinishMove) == 0x000355, "Member 'AActionPropsActor_DN::ResetHandsAfterFinishMove' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, InterruptBehavior) == 0x000356, "Member 'AActionPropsActor_DN::InterruptBehavior' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, InterruptBehaviorReverseMode) == 0x000357, "Member 'AActionPropsActor_DN::InterruptBehaviorReverseMode' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, TrackingTypeWhenFollow) == 0x000358, "Member 'AActionPropsActor_DN::TrackingTypeWhenFollow' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, TranslationScale) == 0x00035C, "Member 'AActionPropsActor_DN::TranslationScale' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, RotationScale) == 0x000360, "Member 'AActionPropsActor_DN::RotationScale' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, Scale3DScale) == 0x000364, "Member 'AActionPropsActor_DN::Scale3DScale' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, SetToStartPosition) == 0x000368, "Member 'AActionPropsActor_DN::SetToStartPosition' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, MoveToStartPosition) == 0x000369, "Member 'AActionPropsActor_DN::MoveToStartPosition' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, MoveToFinalPosition) == 0x00036A, "Member 'AActionPropsActor_DN::MoveToFinalPosition' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, MoveToFinalPositionIndex) == 0x00036C, "Member 'AActionPropsActor_DN::MoveToFinalPositionIndex' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, UsingIntermediatePointIndex) == 0x000370, "Member 'AActionPropsActor_DN::UsingIntermediatePointIndex' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, Reverse) == 0x000374, "Member 'AActionPropsActor_DN::Reverse' has a wrong offset!");
static_assert(offsetof(AActionPropsActor_DN, bActive) == 0x000375, "Member 'AActionPropsActor_DN::bActive' has a wrong offset!");

// Class DynamicNode.DynamicNodeBPLibrary
// 0x0000 (0x0028 - 0x0028)
class UDynamicNodeBPLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddAdditionalRotation_BL(class ACharacter* OwnCharacter, const struct FRotator& AddRotationBase, float TransitionTime, const struct FRotator& AddRotationInCrouch, const struct FRotator& AddRotationInFalling, const struct FRotator& AddRotationInAir, const struct FRotator& AddRotationInWater);
	static void AlignToActor_BL(class ACharacter* OwnCharacter, const class AActor* Actor, class FName BoneToRotate, const struct FVector& PositionOffset, bool OffsetRelative, float MaxDegrees, float TransitionTime, bool CalculateOnce, float RotationAlpha);
	static bool ApplyAdditiveAnimation_BL(class ACharacter* OwnCharacter, class UAnimationAsset* AdditiveAnimation, float IntSpeed, bool PlayOnce, float PlayFrom, bool CanRestart, float IntSpeedIfRestart);
	static bool ApplyAdditiveBSAnimation_BL(class ACharacter* OwnCharacter, class UBlendSpaceBase* AdditiveAnimation, float IntSpeed, float IntSpeedPrevious, const struct FVector& BSDataToPrevious);
	static bool ApplyAimOffset1D_BL(class ACharacter* OwnCharacter, bool OnlyForNextTransition, class UAimOffsetBlendSpace1D* AimOffsetBlendSpace, float InitX);
	static bool ApplyAimOffset2D_BL(class ACharacter* OwnCharacter, bool OnlyForNextTransition, class UAimOffsetBlendSpace* AimOffsetBlendSpace, float InitX, float InitY);
	static void AssignDelegate_AllNotify_BL(class ACharacter* OwnCharacter, const TDelegate<void(uint8 StackPriority, class FName BoneName, class FName NotifyName, class UAnimSequenceBase* LinkedSequence)>& AllNotifyDelegate_Multi);
	static void AssignDelegate_AnimationChange_BL(class ACharacter* OwnCharacter, const TDelegate<void(uint8 StackPriority, class FName BoneName, class UAnimationAsset* OldLinkedSequence, class UAnimationAsset* NewLinkedSequence)>& AnimationChangeNotifyDelegate_Multi);
	static void AssignDelegate_EndOfTrack_Once_BL(class ACharacter* OwnCharacter, const TDelegate<void(uint8 StackPriority, class FName BoneName, class FName NotifyName, class UAnimSequenceBase* LinkedSequence, bool EndOfTrack)>& AllNotifyDelegate_Multi, const class UAnimSequenceBase* AnimationTrack, bool ReplaceIfExist);
	static void AssignDelegate_SpecificNotify_BL(class ACharacter* OwnCharacter, const TDelegate<void(uint8 StackPriority, class FName BoneName, class FName NotifyName, class UAnimSequenceBase* LinkedSequence)>& AllNotifyDelegate_Multi, class FName NotifyName, bool ReplaceIfExist);
	static void AssignDelegate_SpecificNotify_Once_BL(class ACharacter* OwnCharacter, const TDelegate<void(uint8 StackPriority, class FName BoneName, class FName NotifyName, class UAnimSequenceBase* LinkedSequence)>& AllNotifyDelegate_Multi, class FName NotifyName, bool ReplaceIfExist);
	static void AssignDelegate_SpecificNotifyAndAsset_BL(class ACharacter* OwnCharacter, const TDelegate<void(uint8 StackPriority, class FName BoneName, class FName NotifyName, class UAnimSequenceBase* LinkedSequence)>& AllNotifyDelegate_Multi, class FName NotifyName, const class UAnimSequenceBase* AnimationTrack, bool ReplaceIfExist);
	static void AssignDelegate_SpecificNotifyAndAsset_Once_BL(class ACharacter* OwnCharacter, const TDelegate<void(uint8 StackPriority, class FName BoneName, class FName NotifyName, class UAnimSequenceBase* LinkedSequence)>& AllNotifyDelegate_Multi, class FName NotifyName, const class UAnimSequenceBase* AnimationTrack, bool ReplaceIfExist);
	static void AssignDelegate_SpecificNotifyOrEndOfTrack_Once_BL(class ACharacter* OwnCharacter, const TDelegate<void(uint8 StackPriority, class FName BoneName, class FName NotifyName, class UAnimSequenceBase* LinkedSequence, bool EndOfTrack)>& AllNotifyDelegate_Multi, class FName NotifyName, const class UAnimSequenceBase* AnimationTrack, bool ReplaceIfExist);
	static EAnimationReturnTypes_DN BlendMachine_BL(class ACharacter* OwnCharacter, float AlphaValue, class UAnimationAsset* FirstAnimation, class UAnimationAsset* SecondAnimation, class UAnimationAsset* ThirdAnimation, float TransitionTime, float InPlayRate, float InThirdPlayRate, float MaxSecondValue);
	static EAnimationReturnTypes_DN BlendMachine_BlendSpace2D_BL(class ACharacter* OwnCharacter, float BledSpaceValueX, float BledSpaceValueY, class UBlendSpace* BlendSpaceAnimation, float PlayRate);
	static EAnimationReturnTypes_DN BlendMachine_BlendSpace_BL(class ACharacter* OwnCharacter, float BledSpaceValue, class UBlendSpace1D* BlendSpaceAnimation, float PlayRate);
	static void BreakEquipThing_BL(class ACharacter* OwnCharacter, bool EnablePhysSimWhenTransition);
	static struct FVector2D CalculateLeanVector_BL(class ACharacter* OwnCharacter, float MinSpeed, float MaxSpeed, float XValFactorDiection, float YValFactorAcceleration, float YValFactorBracking, float VelocityCurve_NoBreak_VelocityThreshold, float VelocityCurve_NoAccel_VelocityThreshold);
	static void CalibrateRearSocketWeightLegsIK_BL(class ACharacter* OwnCharacter, bool Enabled, bool IsProne, const struct FRotator& DeltaRotationRoot);
	static bool CapsuleTraceMulti_DN(class ACharacter* OwnCharacter, const struct FVector& Start, const struct FVector& End, const struct FRotator& Rotation, float Radius, float HalfHeight, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace_DN DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool CapsuleTraceSingle_DN(class ACharacter* OwnCharacter, const struct FVector& Start, const struct FVector& End, const struct FRotator& Rotation, float Radius, float HalfHeight, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace_DN DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static class APropsActorZone_DN* CheckActorZoneOverlap_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, class AActor* Actor);
	static bool CheckSpecificTransitionZone_BL(class ACharacter* OwnCharacter, ETransitionZoneStatus_DN* TransitionZoneB, int32 QueryID, class FName ZoneType);
	static bool CheckTransitionZone_BL(class ACharacter* OwnCharacter, ETransitionZoneStatus_DN* TransitionZoneB, int32 QueryID);
	static float ClampZeroPoint_BL(float Value, float Min, float Max, float MinNegative, float MaxNegative);
	static void ClearDistanceIndexMap_DN();
	static class UAnimChanceSet_DN* CreateAnimChanceSet_BL(class ACharacter* OwnCharacter, const TArray<struct FAnimChanceData_DN>& AnimSequenceArray, float PauseBetweenChoices, bool RandomStartIndex, bool ContainsInternalSets);
	static class UAnimTransitionSet_DN* CreateAnimTransitionSet_BL(class ACharacter* OwnCharacter, class UAnimationAsset* ToAnimation, const TArray<struct FTransitionSetData_DN>& AnimTransitionArray, bool UseEmptyArrayUseClassOnlyForSetManually);
	static class UAnimVariationSet_DN* CreateAnimVariationSet_BL(class ACharacter* OwnCharacter, const TArray<struct FVariationSetData_DN>& AnimSequenceArray, int32 CurrentIndex, bool IteratingEnable, bool ContainsInternalSets);
	static class ULoopNAnimationAsset_DN* CreateLoopNAnimationAsset_BL(class ACharacter* OwnCharacter, class UAnimSequence* AnimSequence, class FName LoopStartNotify, class FName LoopEndNotify, float PlayRate, float TransitionTime, float StartLoopingDeltaTime);
	static EAnimationReturnTypes_DN CrouchMachine_BL(class ACharacter* OwnCharacter, class UAnimationAsset* CrouchAnimation, class UAnimationAsset* CrouchIdleAnimation, class UAnimationAsset* StandingAnimation, bool UseReverseStartAsEndAnimation, float TransitionTime_ToC, float TransitionTime_CIdle, float TransitionTime_SU, float PlayRate, float TransitionTimeQuickReturn);
	static EAnimationReturnTypes_DN CustomStateMachine_BL(class ACharacter* OwnCharacter, int32 CustomIndex, bool UseAccelerationForDM, bool ForcePlayToStateAnimationTillEnd, bool ForcePlayFromStateAnimationTillEnd, class UAnimationAsset* ToStateAnimation, class UAnimationAsset* IdleAnimation, class UAnimationAsset* FromStateAnimation, bool UseReverseStartAsEndAnimation, float TransitionTime_ToS, float TransitionTime_Idle, float TransitionTime_FS, float PlayRate, float TransitionTimeQuickReturn);
	static bool DisableAdditiveAnimation_BL(class ACharacter* OwnCharacter, float IntSpeed);
	static bool DisableAdditiveBSAnimation_BL(class ACharacter* OwnCharacter, float IntSpeed);
	static bool DisableAimOffsetForNextTr_BL(class ACharacter* OwnCharacter, class FName BoneName);
	static bool DisableAllAdditiveAnimation_BL(class ACharacter* OwnCharacter, float IntSpeed);
	static void DisableAllBlendBoneStacksPause_BL(class ACharacter* OwnCharacter);
	static void DisableAllErrorInfo_DN(bool Disable);
	static void DisableDelegateOnAnimFinBlend_BL(class ACharacter* OwnCharacter, class FName BoneName, bool ContinueFinishStack);
	static void DisableInfoStrings_BL(bool Disable);
	static void DisableLegsIKWhenMovingDownhill_BL(class ACharacter* OwnCharacter, bool Disable);
	static void DisableLookAt_BL(class ACharacter* OwnCharacter, float TransitionTime);
	static void DisableTurnInPlaceAnimations_BL(class ACharacter* OwnCharacter, bool Disabled);
	static void DisableTurnToControlRotation_BL(class ACharacter* OwnCharacter, bool Disable);
	static bool DoubleMultiTransitionToAnimFromCurPose_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, class UAnimationAsset* ToNewAsset, float TransitionTime, float PlayFrom, float PlayTill, class UAnimationAsset* FinalAsset, float TransitionTime_final, bool bIsLooping_Final, float InPlayRate, float InStartPosition_Final, float InPlayRate_Final, bool UseSyncGroups);
	static bool DoubleTransitionToAnimFromCurPose_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, class UAnimationAsset* ToNewAsset, float TransitionTime, float PlayFrom, float PlayTill, class UAnimationAsset* FinalAsset, float TransitionTime_final, bool bIsLooping_Final, float InPlayRate, float InStartPosition_Final, float InPlayRate_Final);
	static struct FRotator EliminateYaw_DN(const struct FRotator& Rotator);
	static void EndAnimationStack_BL(class ACharacter* OwnCharacter);
	static bool EquipThing_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, class UAnimationAsset* AnimationToPlay, const TArray<struct FEquipThingData_DN>& EquipThingData, const TDelegate<void(int32 WeaponIndex, class FName NotifyToAction, bool FinishTransform)>& DelegatesOnComplited, class FName PlayFromNotify, class FName PlayTillNotify, float TransitionTime, float PlayRate, bool CanRestartAnimation);
	static struct FRotator FindBetweenNormals_DN(const struct FVector& Vector1, const struct FVector& Vector2, struct FQuat* Quat);
	static void FinishAnimationBlendBoneAnimFin_BL(class ACharacter* OwnCharacter, float TransitionTime, float TransitionEndOffset);
	static void FinishAnimationBlendBoneStack_BL(class ACharacter* OwnCharacter, class FName BoneName, uint8 StackPriority, float TransitionTime);
	static EAnimationReturnTypes_DN FlyMachine_BL(class ACharacter* OwnCharacter, class UAnimationAsset* StartFlyAnimation, class UAnimationAsset* IdleFlyAnimation, class UAnimationAsset* EndFlyAnimation, bool UseOnlyAccelerationForDM, float IdlePoseVelocityTreshold, bool UseReverseStartAsEndAnimation, float TransitionTime_ToF, float TransitionTime_FIdle, float TransitionTime_EF, float PlayRate, float TransitionTimeQuickReturn);
	static void ForceNextTransitionNOTMulti_BL(class ACharacter* OwnCharacter, bool NextNOTMulti);
	static void ForceUpdateCurMachineAnimation_BL(class ACharacter* OwnCharacter, bool Update);
	static void ForceUsePivotThisFrame_BL(class ACharacter* OwnCharacter);
	static bool FromRagdoll_BL(class ACharacter* OwnCharacter, float TransitionTime);
	static bool FromRagdollAnim_BL(class ACharacter* OwnCharacter, bool IsFacingUp, bool IsVerticalPose, class UAnimationAsset* AnimationFromBackside, class UAnimationAsset* AnimationFromFrontSide, class UAnimationAsset* AnimationFromVerticalPose, class FName PlayFromNotify, class FName PlayTillNotify, float PlayRate, float TransitionTime);
	static class UBlendSpaceBase* GetAimOffsetAnimaAsset_BL(class ACharacter* OwnCharacter, class FName BoneName);
	static class UAnimMultiNodeInstance_DN* GetAnimInstanceFromCharacter_BL(class ACharacter* OwnCharacter);
	static void GetCurrentAnimation_BL(class ACharacter* OwnCharacter, class UAnimationAsset** AnimationAsset, class FName BoneName);
	static struct FRotator GetCurrentRootDeltaRotationCS_BL(class ACharacter* OwnCharacter);
	static float GetCurrentSlopeAngleCS_BL(class ACharacter* OwnCharacter);
	static void GetCurrentTrackInfo_BL(class ACharacter* OwnCharacter, class UAnimationAsset** AnimationAsset, class UAnimationAsset** TransitionFromAnimationAsset, bool* InTransition, float* FullLenght, float* CurrentTime, float* PlayRate, bool* IsLooping, class FName BoneName);
	static float GetCurrentTrackPlaytime_BL(class ACharacter* OwnCharacter, class FName BoneName);
	static void GetCurrentTrackTimeInfo_BL(class ACharacter* OwnCharacter, float* FullLenght, float* CurrentTime, float* OverallPlayTime, class FName BoneName);
	static void GetEndSwimmStatus_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches);
	static void GetFlyMachineMoveStatus_BL(class ACharacter* OwnCharacter, EAccelerationStatus_DN* AccelerationStatus);
	static void GetGroundZeroLevelCSLegsIK_BL(class ACharacter* OwnCharacter, int32 LegIndex, float* LegZeroLevelCS_Right, float* LegZeroLevelCS_Left, bool GetDifference);
	static float GetHandSpeedCSHandsIK_BL(class ACharacter* OwnCharacter, int32 HandIndex);
	static struct FRotator GetHorizontalPoseMeshRotation_BL(class ACharacter* OwnCharacter, bool IsFacingUp, class FName LowerSpineBoneName, class FName UpperSpineBoneName);
	static float GetLastBlendSpaceMapVelocityValue_BL(class ACharacter* OwnCharacter);
	static struct FVector GetLastComplexNormalLegsIK_Left_BL(class ACharacter* OwnCharacter, int32 LegIndex);
	static struct FVector GetLastComplexNormalLegsIK_Right_BL(class ACharacter* OwnCharacter, int32 LegIndex);
	static struct FVector GetLastHitPointLegsIK_LeftFront_BL(class ACharacter* OwnCharacter, int32 LegIndex);
	static struct FVector GetLastHitPointLegsIK_LeftRear_BL(class ACharacter* OwnCharacter, int32 LegIndex);
	static struct FVector GetLastHitPointLegsIK_RightFront_BL(class ACharacter* OwnCharacter, int32 LegIndex);
	static struct FVector GetLastHitPointLegsIK_RightRear_BL(class ACharacter* OwnCharacter, int32 LegIndex);
	static struct FRotator GetLastOrientationLegsIK_Left_BL(class ACharacter* OwnCharacter, int32 LegIndex, bool UseZYAxis, bool Inverse, bool GetSimpleNormal);
	static struct FRotator GetLastOrientationLegsIK_Right_BL(class ACharacter* OwnCharacter, int32 LegIndex, bool UseZYAxis, bool Inverse, bool GetSimpleNormal);
	static void GetLastPrelandedDistanceToWater_BL(class ACharacter* OwnCharacter, float* OutDistanceToWater);
	static void GetLastPrelandedHeight_BL(class ACharacter* OwnCharacter, float* LastPrelandedHeight);
	static void GetLastPrelandedWaterDepth_BL(class ACharacter* OwnCharacter, float* OutWaterDepth);
	static struct FVector GetLastTraceNormalLegsIK_Left_BL(class ACharacter* OwnCharacter, int32 LegIndex);
	static struct FVector GetLastTraceNormalLegsIK_Right_BL(class ACharacter* OwnCharacter, int32 LegIndex);
	static struct FVector GetLocationBeforeIKHandsIK_BL(class ACharacter* OwnCharacter, int32 HandIndex, bool GetComponentSpace);
	static struct FVector GetNormalBy3Point_BL(const struct FVector& A_RUp, const struct FVector& B_LUp, const struct FVector& C_Bot);
	static struct FVector GetNormalBy4Point_BL(const struct FVector& A_RUp, const struct FVector& B_LUp, const struct FVector& C_RBot, const struct FVector& D_LBot);
	static float GetNotifyDeltaTime_BL(class ACharacter* OwnCharacter, class FName NotifyName, class FName NotifyName2, bool UseCurrentAnimAsset, class UAnimationAsset* FromSpecificAnimAsset);
	static float GetNotifyTime_BL(class ACharacter* OwnCharacter, class FName NotifyName, bool UseCurrentAnimAsset, class UAnimationAsset* FromSpecificAnimAsset);
	static void GetPrelandedHitInfo_BL(class ACharacter* OwnCharacter, struct FHitResult* HitResult);
	static void GetPrelandedWaterHitInfo_BL(class ACharacter* OwnCharacter, struct FHitResult* HitResult, bool* IsHitFound);
	static TArray<float> GetSortedDistanceArray_DN(bool UseReverse);
	static TArray<int32> GetSortedDistanceIndexArray_DN(bool UseReverse);
	static void GetStartSwimmStatus_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches);
	static void GetSwimmMachineMoveStatus_BL(class ACharacter* OwnCharacter, ESwimmingStatus_DN* SwimmingStatus);
	static struct FRotator GetVerticalPoseMeshRotation_BL(class ACharacter* OwnCharacter, class FName RootBoneName, const struct FVector& Axis);
	static void HandsCCDIKAlignToActor_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, const TDelegate<void(int32 HandIndex)>& EventOnComplited, const TDelegate<void(int32 HandIndex)>& MoveOutOfRangeDelegate, int32 HandIndex, class UAnimSequence* PreAlignHandAnimation, class FName HandAnimPlayFromNotify, float HandAnimTransitionTime, class AActor* TargetActor, const struct FVector& ActorOffset, bool OffsetRelative, class FName HandSocketName, const struct FRotator& AddHandRotation, float ClampHandDeltaAngle, int32 MaxIterToFixClampPosition, const struct FRotator& AddUpperarmRotation, float TimeToMove, float ClampDirectionAngleLeft, float ClampDirectionAngleRight, float CalmpDistanceHandLength_Min, float CalmpDistanceHandLength_Max, float FinalPositionTolerance);
	static void HandsCCDIKAlignToMesh_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, const TDelegate<void(int32 HandIndex)>& EventOnComplited, const TDelegate<void(int32 HandIndex)>& MoveOutOfRangeDelegate, int32 HandIndex, class UAnimSequence* PreAlignHandAnimation, class FName HandAnimPlayFromNotify, float HandAnimTransitionTime, class UMeshComponent* TargetMComponent, const struct FVector& MeshOffset, bool OffsetRelative, class FName HandSocketName, const struct FRotator& AddHandRotation, float ClampHandDeltaAngle, int32 MaxIterToFixClampPosition, const struct FRotator& AddUpperarmRotation, float TimeToMove, float ClampDirectionAngleLeft, float ClampDirectionAngleRight, float CalmpDistanceHandLength_Min, float CalmpDistanceHandLength_Max, float FinalPositionTolerance);
	static void HandsCCDIKAlignToSocket_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, const TDelegate<void(int32 HandIndex)>& EventOnComplited, const TDelegate<void(int32 HandIndex)>& MoveOutOfRangeDelegate, int32 HandIndex, class UAnimSequence* PreAlignHandAnimation, class FName HandAnimPlayFromNotify, float HandAnimTransitionTime, class UMeshComponent* TargetMComponent, class FName TargetSocketName, class FName HandSocketName, const struct FRotator& AddHandRotation, float ClampHandDeltaAngle, int32 MaxIterToFixClampPosition, const struct FRotator& AddUpperarmRotation, float TimeToMove, float ClampDirectionAngleLeft, float ClampDirectionAngleRight, float CalmpDistanceHandLength_Min, float CalmpDistanceHandLength_Max, float FinalPositionTolerance);
	static void HandsCCDIKCheckConeAngle_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, int32 HandIndex, float* LeftMove, float* RightMove, class AActor* TargetActor, const struct FVector& ActorOffset, bool OffsetRelative, float ClampDirectionAngleLeft, float ClampDirectionAngleRight);
	static float HandsCCDIKCheckDistance_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, int32 HandIndex, class AActor* TargetActor, const struct FVector& ActorOffset, bool OffsetRelative, float CalmpDistanceHandLength_Min, float CalmpDistanceHandLength_Max);
	static float HandsCCDIKCheckDistanceXY_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, int32 HandIndex, class AActor* TargetActor, const struct FVector& ActorOffset, bool OffsetRelative, float CalmpDistanceHandLength_Min, float CalmpDistanceHandLength_Max);
	static void HandsCCDIKFollowActionPropsActor_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, const TDelegate<void(bool Reverse, bool StartMove, int32 IntermediatePointsReached, bool HandMoveBack, bool EndAction)>& EventOnComplited, const TDelegate<void(int32 HandIndex)>& MoveOutOfRangeDelegate, int32 HandIndex, class UAnimSequence* HandAnimation, class FName HandAnimPlayFromNotify, float HandAnimTransitionTime, float HandAnimStartMovingOffset, class AActionPropsActor_DN* ActionPropsActor, class FName HandSocketName, const struct FRotator& AddUpperarmRotation, float TimeToMove, float TimeToMoveBack, float ClampDirectionAngleLeft, float ClampDirectionAngleRight, float CalmpDistanceHandLength_Min, float CalmpDistanceHandLength_Max, float FinalPositionTolerance);
	static void HandsCCDIKFollowActionPropsActor_TwoHands_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, const TDelegate<void(bool Reverse, bool StartMove, int32 IntermediatePointsReached, bool HandMoveBack, bool EndAction)>& EventOnComplited, const TDelegate<void(int32 HandIndex)>& MoveOutOfRangeDelegate, const TArray<struct FHandTargetSocketPairs_DN>& HandIdxTargetSocketPairs, class AActionPropsActor_DN* ActionPropsActor, float TimeToMove, float TimeToMoveBack, float ClampDirectionAngleLeft, float ClampDirectionAngleRight, float CalmpDistanceHandLength_Min, float CalmpDistanceHandLength_Max, float FinalPositionTolerance);
	static void HandsCCDIKFollowCustomActor_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, const TDelegate<void(int32 HandIndex)>& EventOnComplited, const TDelegate<void(int32 HandIndex)>& MoveOutOfRangeDelegate, int32 HandIndex, class UAnimSequence* HandAnimation, class FName HandAnimPlayFromNotify, float HandAnimTransitionTime, class UMeshComponent* TargetMeshComponent, class FName HandSocketName, const TArray<struct FHandsCCDIKTargetHandFollowData_DN>& TargetHandDataArray, const struct FRotator& AddUpperarmRotation, float TimeToMove, float ClampDirectionAngleLeft, float ClampDirectionAngleRight, float CalmpDistanceHandLength_Min, float CalmpDistanceHandLength_Max, float FinalPositionTolerance);
	static void HandsCCDIKGrabActor_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, const TDelegate<void(int32 HandIndex, class FName SocketName, class AActor* Actor)>& EventOnComplited, int32 HandIndex, class UAnimSequence* GrabAnimation, float TransitionTime, float AnimTimerOffset, class FName StartNotifyName_Optional, class FName GrabSocketNameOverride, EAttachmentRule LocationRule, EAttachmentRule RotationRule, float AttachmentTransitionDuration, float TargetPositionTolerance);
	static void HandsCCDIKPrepareToPressButton_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, const TDelegate<void(int32 HandIndex)>& MoveOutOfRangeDelegate, int32 HandIndex, class AActor* TargetActor, const struct FVector& ActorOffset, bool OffsetRelative, const struct FRotator& AddUpperarmRotation, float TimeToMove, float ClampDirectionAngleLeft, float ClampDirectionAngleRight, float CalmpDistanceHandLength_Min, float CalmpDistanceHandLength_Max, bool ResetIfMoving);
	static void HandsCCDIKPressButton_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, const TDelegate<void(int32 HandIndex, bool StartPressing)>& EventOnComplited, int32 HandIndex, class AActor* TargetActor, const struct FVector& ActorOffset, bool OffsetRelative, bool HideFingerWhenBack, bool UsePreparePositionWhenBack, int32 BackMoveBoneIndex, float BackMoveDistance, const struct FRotator& AddUpperarmRotation, float TimeToMove, float TimeToPress, float TimeToBack, float FinalPositionTolerance);
	static void HandsCCDIKPressButtonSimple_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, const TDelegate<void(int32 HandIndex, bool StartPressing)>& EventOnComplited, int32 HandIndex, class AActor* TargetActor, const struct FVector& ActorOffset, bool OffsetRelative, const struct FRotator& AddUpperarmRotation, float TimeToMove, float TimeToPress, float TimeToBack, float ClampDirectionAngleLeft, float ClampDirectionAngleRight, float CalmpDistanceHandLength_Min, float CalmpDistanceHandLength_Max, float FinalPositionTolerance);
	static void HandsCCDIKReset_BL(class ACharacter* OwnCharacter, int32 HandIndex, float TimeToMove, bool ResetHandAnimation);
	static void HandsCCDIKResetHandMoveWhenCharacterMove_BL(class ACharacter* OwnCharacter, int32 HandIndex, bool Reset);
	static void HandsCCDIKResetPropsActor_BL(class ACharacter* OwnCharacter, int32 HandIndex, class AActionPropsActor_DN* ActionPropsActor);
	static void HandsCCDIKSetActorTarget_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, const TDelegate<void(int32 HandIndex)>& EventOnComplited, const TDelegate<void(int32 HandIndex)>& EventMoveOutOfRange, int32 HandIndex, class AActor* TargetActor, const struct FVector& ActorOffset, bool OffsetRelative, bool ActorIsMovable, const struct FRotator& AddUpperarmRotation, float TimeToMove, float ClampDirectionAngleLeft, float ClampDirectionAngleRight, float CalmpDistanceHandLength_Min, float CalmpDistanceHandLength_Max);
	static void HandsCCDIKSetComponentSpaceTarget_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, const TDelegate<void(int32 HandIndex)>& EventOnComplited, int32 HandIndex, const struct FVector& Target_CS, const struct FRotator& AddUpperarmRotation, float TimeToMove, float ClampDirectionAngleLeft, float ClampDirectionAngleRight, float CalmpDistanceHandLength_Min, float CalmpDistanceHandLength_Max, float FinalPositionTolerance);
	static void HandsCCDIKSetNewTrackingParams_BL(class ACharacter* OwnCharacter, int32 HandIndex, float ClampDirectionAngleLeft, float ClampDirectionAngleRight, float CalmpDistanceHandLength_Min, float CalmpDistanceHandLength_Max);
	static void HandsCCDIKSetWorldSpaceTarget_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, const TDelegate<void(int32 HandIndex)>& EventOnComplited, int32 HandIndex, const struct FVector& Target_WS, const struct FRotator& AddUpperarmRotation, float TimeToMove, float ClampDirectionAngleLeft, float ClampDirectionAngleRight, float CalmpDistanceHandLength_Min, float CalmpDistanceHandLength_Max, float FinalPositionTolerance);
	static void HandsCCDIKStartGrabActor_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, const TDelegate<void(int32 HandIndex)>& EventOnComplited, const TDelegate<void(int32 HandIndex)>& MoveOutOfRangeDelegate, int32 HandIndex, class UAnimSequence* PreGrabHandAnimation, class FName HandAnimPlayFromNotify, float HandAnimTransitionTime, class AActor* TargetActor, const struct FVector& ActorOffset, bool OffsetRelative, class FName GrabSocketName, const struct FHandsCCDIKAlignHandData_DN& AlignHandToActor, const struct FRotator& AddUpperarmRotation, float TimeToMove, float ClampDirectionAngleLeft, float ClampDirectionAngleRight, float CalmpDistanceHandLength_Min, float CalmpDistanceHandLength_Max, float FinalPositionTolerance);
	static void HandsCCDIKUseGrabActorRelativeSocket_BL(class ACharacter* OwnCharacter, int32 HandIndex, bool UseRelativeActorSocket, class AActor* TargetActor, class FName SocketName, bool ApplyRelativeTransformBeforeHandSocket);
	static void HandsIKCalibrate_BL(class ACharacter* OwnCharacter, int32 HandIndex, const struct FRotator& DeltaRotation, class FString* OutRotatorStr);
	static void HandsIKGetTransitionTime_BL(class ACharacter* OwnCharacter, int32 HandIndex, float* TransitionTimeTranslation, float* TransitionTimeRotation);
	static void HandsIKMoveToActor_BL(class ACharacter* OwnCharacter, int32 HandIndex, class AActor* Actor, bool SolveUpperarm, float ClampDirectionAngleLeft, float ClampDirectionAngleRight, bool ResetOffset);
	static void HandsIKOverrideSpecificData_BL(class ACharacter* OwnCharacter, int32 HandIndex, const TArray<struct FHandsIKSpecificDataOverride_DN>& HandsIKSpecificDataArray);
	static void HandsIKResetAll_BL(class ACharacter* OwnCharacter, int32 HandIndex);
	static void HandsIKSetInitDeltaHandRotation_BL(class ACharacter* OwnCharacter, int32 HandIndex, const struct FRotator& InitRotation);
	static void HandsIKSetOffsetRotation_BL(class ACharacter* OwnCharacter, int32 HandIndex, const struct FRotator& OffsetRotator_CS);
	static void HandsIKSetOffsetTranslation_BL(class ACharacter* OwnCharacter, int32 HandIndex, const struct FVector& Offset_CS, bool SolveUpperarm);
	static void HandsIKSetTransitionTime_BL(class ACharacter* OwnCharacter, int32 HandIndex, float TransitionTimeTranslation, float TransitionTimeRotation);
	static void HandsIKSetTransitionTimeNext_BL(class ACharacter* OwnCharacter, int32 HandIndex, float CurTransitionTimeTranslation, float CurTransitionTimeRotation, float NextTransitionTimeTranslation, float NextTransitionTimeRotation);
	static void HandsIKSetWorldSpaceRotation_BL(class ACharacter* OwnCharacter, int32 HandIndex, const struct FRotator& TargetRotator_WS, bool Enabled);
	static void HandsIKSetWorldSpaceTranslation_BL(class ACharacter* OwnCharacter, int32 HandIndex, const struct FVector& Target_WS, bool SolveUpperarm, float ClampDirectionAngleLeft, float ClampDirectionAngleRight, float CalmpDistanceHandLength, bool Enabled);
	static void HandsIKStopTracking_BL(class ACharacter* OwnCharacter, int32 HandIndex);
	static void HandsIKTurnToActor_BL(class ACharacter* OwnCharacter, int32 HandIndex, class AActor* Actor, float ClampDirectionAngleLeft, float ClampDirectionAngleRight, bool ResetOffset);
	static bool HasDefferedTransitionAnimation_BL(class ACharacter* OwnCharacter, class FName BoneName);
	static void IfWaterDepthMoreThan_BL(class ACharacter* OwnCharacter, float TestWaterDepth, EBranchesOutEnum* Branches);
	static EAnimationReturnTypes_DN ImpactHandle_BL(class ACharacter* OwnCharacter, class UAnimationAsset* ImpactAnimation, class FName PlayTill_Notify, float TransitionTime, float ImpulseAmplitude, bool bOverrideImpactDirection, const struct FVector& OverrideImpactDirectionVector);
	static void InsertDistanceIndexMap_DN(float Distance, int32 Param_Index, bool ClearMapBeforeInsert);
	static bool IsAimOffsetEnabled_BL(class ACharacter* OwnCharacter, class FName BoneName);
	static bool IsAnimationSelectedInAnimationStack_BL(class ACharacter* OwnCharacter);
	static bool IsAnimationStackActive_BL(class ACharacter* OwnCharacter);
	static bool IsAssetPlaying_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, class FName BoneName, class UAnimationAsset* AnimationAsset);
	static bool IsBoxesIntersect_DN(const struct FBox& Box1, const struct FBox& Box2);
	static bool IsCharacterInWaterVolume_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, float* DepthOut, float DepthLimit);
	static bool IsCharacterInWaterVolumePure_BL(class ACharacter* OwnCharacter, float* DepthOut, float DepthLimit);
	static bool IsDelegateOnAnimFinBlendBound_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, class FName BoneName);
	static void IsDiving_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches);
	static bool IsEquipUnequip_Active_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches);
	static bool IsFacingUp_3Bone_BL(class ACharacter* OwnCharacter, class FName PelvisBoneName, class FName Spine_1BoneName, class FName Spine_2BoneName, const struct FVector& Axis);
	static bool IsFacingUp_BL(class ACharacter* OwnCharacter, class FName PelvisBoneName, const struct FVector& Axis);
	static bool IsImpactAnimationPlay_BL(class ACharacter* OwnCharacter);
	static void IsJumpInWater_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches);
	static bool IsLookAtActor_BL(class ACharacter* OwnCharacter, EBranchesEOutEnum_DN* Branches, class AActor* Actor, bool CheckPendingDisabled);
	static bool IsLookAtEnable_BL(class ACharacter* OwnCharacter, EBranchesEOutEnum_DN* Branches, bool CheckPendingDisabled);
	static void IsPrelanded_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches);
	static bool IsShallowWaterMoving_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches);
	static void IsShallowWaterMovingEnd_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches);
	static void IsSurfacing_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches);
	static bool IsVerticalPose_BL(class ACharacter* OwnCharacter, class FName LowerSpineBoneName, class FName UpperSpineBoneName, float* VerticalFactorOut, float VerticalFactor);
	static bool IsVerticalPoseRayTrace_BL(class ACharacter* OwnCharacter, class FName LowerSpineBoneName, class FName UpperSpineBoneName, float TraceHeight, float* VerticalFactorOut, float VerticalFactor, bool ShowDebug);
	static EAnimationReturnTypes_DN JumpMachine_BL(class ACharacter* OwnCharacter, class UAnimationAsset* StartJumpAnimation, class UAnimationAsset* FallingAnimation, class UAnimationAsset* LandedAnimation, class FName StartJumpPlayTillNotify, class FName LandedPlayFromNotify, class FName LandedPlayTillNotify, float TransitionTime_SJ, float TransitionTime_FLoop, float TransitionTime_L, float PlayRate, float MovementSpeedWhenDisableLanded);
	static void JumpMachine_BlockMovementUntilLandedFin_BL(class ACharacter* OwnCharacter, class UAnimationAsset* LandedAnimation, bool BlockMovementAndRotation);
	static void JumpMachine_BlockMovementUntilLandedFin_OneFrame_BL(class ACharacter* OwnCharacter, bool BlockMovementAndRotation);
	static EAnimationReturnTypes_DN JumpMachineExt_BL(class ACharacter* OwnCharacter, class UAnimationAsset* StartJumpAnimation, class UAnimationAsset* FallingAnimation, class UAnimationAsset* LongFallingAnimation, class UAnimationAsset* PreLandedAnimationOptional, class UAnimationAsset* LandedAnimation, class FName StartJumpPlayTillNotify, class FName LandedPlayFromNotify, class FName LandedPlayTillNotify, float TransitionTime_SJ, float TransitionTime_FLoop, float TransitionTime_LFLoop, float TransitionTime_PL_Optional, float TransitionTime_L, float PlayRate, float MovementSpeedWhenDisableLanded, float LongFallingThresholdVelocity, bool LongFallingThresholdUseOnlyZVel, float PreLandedHeightOptional, float PreLandedVelocityTresholdOptional);
	static void JumpMachineExt_MoveTracePoint_OneFrame_BL(class ACharacter* OwnCharacter, float VelocityVectorDistance, float ZDecreaseFactor);
	static void JumpMachineExt_SetTraceOffset_OneFrame_BL(class ACharacter* OwnCharacter, const struct FVector& TraceOffsetWS);
	static EAnimationReturnTypes_DN JumpMachineSimple_BL(class ACharacter* OwnCharacter, class UAnimationAsset* JumpAnimation, class FName StartJumpPlayFromNotify, class FName StartJumpPlayTillNotify, class FName LandedPlayFromNotify, class FName LandedPlayTillNotify, float TransitionTime_SJ, float TransitionTime_FLoop, float TransitionTime_L, float PlayRate, float MovementSpeedWhenDisableLanded);
	static EAnimationReturnTypes_DN LayMachine_BL(class ACharacter* OwnCharacter, class UAnimationAsset* LieDownAnimation, class UAnimationAsset* IdleAnimation, class UAnimationAsset* GetUpAnimation, bool UseReverseStartAsEndAnimation, float TransitionTime_ToLD, float TransitionTime_LIdle, float TransitionTime_GU, float PlayRate, float TransitionTimeQuickReturn);
	static void LookAtActor_BL(class ACharacter* OwnCharacter, const class AActor* Actor, class FName AnchorBone, class FName BoneToRotate, const struct FVector& PositionOffset, bool OffsetRelative, bool UsePinch, float MaxDegrees, float Clamp_MaxYawToLookAt_Degrees, bool DisableLookAtWhenMaxYaw, float TransitionTime, bool CalculateOnce, float RotationAlpha);
	static void LookAtActorBone_BL(class ACharacter* OwnCharacter, const class AActor* Actor, class FName AnchorBone, class FName BoneToRotate, class FName BoneToLookAt, const struct FVector& PositionOffset, bool OffsetRelative, bool UsePinch, float MaxDegrees, float Clamp_MaxYawToLookAt_Degrees, bool DisableLookAtWhenMaxYaw, float TransitionTime, bool CalculateOnce, float RotationAlpha);
	static void LookAtBone_BL(class ACharacter* OwnCharacter, class FName AnchorBone, class FName BoneToRotate, class FName BoneToLookAt, const struct FVector& PositionOffset, bool OffsetRelative, bool UsePinch, float MaxDegrees, float TransitionTime, bool CalculateOnce, float RotationAlpha);
	static void LookAtSetAssetInitialDeltaRotation_BL(class ACharacter* OwnCharacter, class UAnimationAsset* AnimationAsset, const struct FRotator& InitialDeltaRotation);
	static void LookAtSetInitialDeltaRotation_BL(class ACharacter* OwnCharacter, const struct FRotator& InitialDeltaRotation);
	static void LookAtSetMeshVectors_BL(class ACharacter* OwnCharacter, const struct FVector& ForwardVector, const struct FVector& UpVector);
	static void MontageSetup_BL(class ACharacter* OwnCharacter, class UAnimMontage* AnimationAsset, bool BreakIfMovementStatusChanged, float BreakIfStartMovingSecAfterStart, float CanRestartMontageSecAfterStart);
	static void MoveHandTowardSpineHandsIK_BL(class ACharacter* OwnCharacter, int32 HandIndex, float MoveDistance, const struct FVector& SpinePosOffsetCS, float IntSpeed);
	static EAnimationReturnTypes_DN MoveMachine_BL(class ACharacter* OwnCharacter, class UAnimationAsset* IdleAnimation, class FName IdleAssetIsPose_Notify, class UAnimationAsset* MoveAnimation, class UAnimationAsset* RunAnimation, float TransitionTimeIdle, float TransitionTimeMove, float TransitionTimeRun, float PlayRate, float RunPlayRate, float MaxWalkSpeed, bool DropPlayRateWhenSmallVel, float DropPlayRateCoef, float MinDropRateValue, float ImpactHandleMoveCoef, bool RandomStartPosition);
	static EAnimationReturnTypes_DN MoveMachineExt_BL(class ACharacter* OwnCharacter, class UAnimationAsset* IdleAnimation, class FName IdleAssetIsPose_Notify, class UAnimationAsset* StartMoveAnimation, class FName StartMovePlayTill_Notify, class UAnimationAsset* MoveAnimation, class FName MovePlayFrom_Notify, class UAnimationAsset* EndMoveAnimationOptional, class FName EndMovePlayFrom_Notify, class UAnimationAsset* RunAnimation, float TransitionTime, float TransitionTimeSM, float TransitionTimeM, float TransitionTimeEM, float TransitionTimeRun, float PlayRate, float RunPlayRate, float MaxWalkSpeed, float StartStoppingCoef);
	static EAnimationReturnTypes_DN MoveMachineExtMulti_2Legs_BL(class ACharacter* OwnCharacter, class UAnimationAsset* IdleAnimation, class FName IdleAssetIsPose_Notify, class UAnimationAsset* StartMoveAnimation, class FName StartMovePlayTill_Notify, class UAnimationAsset* MoveAnimation, class FName MovePlayFrom_Notify, class UAnimationAsset* EndMoveAnimationOptional_Right, class UAnimationAsset* EndMoveAnimationOptional_Left, class FName EndMovePlayFrom_Notify, class UAnimationAsset* RunAnimation, float TransitionTime, float TransitionTimeSM, float TransitionTimeM, float TransitionTimeEM, float TransitionTimeRun, float PlayRate, float RunPlayRate, float MaxWalkSpeed, float StartStoppingCoef, bool SyncAnimations);
	static EAnimationReturnTypes_DN MoveMachineExtMulti_BL(class ACharacter* OwnCharacter, class UAnimationAsset* IdleAnimation, class FName IdleAssetIsPose_Notify, class UAnimationAsset* StartMoveAnimation, class FName StartMovePlayTill_Notify, class UAnimationAsset* MoveAnimation, class FName MovePlayFrom_Notify, class UAnimationAsset* EndMoveAnimationOptional, class FName EndMovePlayFrom_Notify, class UAnimationAsset* RunAnimation, float TransitionTime, float TransitionTimeSM, float TransitionTimeM, float TransitionTimeEM, float TransitionTimeRun, float PlayRate, float RunPlayRate, float MaxWalkSpeed, float StartStoppingCoef, bool SyncAnimations);
	static EAnimationReturnTypes_DN MoveMachineMulti_BL(class ACharacter* OwnCharacter, class UAnimationAsset* IdleAnimation, class FName IdleAssetIsPose_Notify, class UAnimationAsset* MoveAnimation, class UAnimationAsset* RunAnimation, float TransitionTimeIdle, float TransitionTimeMove, float TransitionTimeRun, float PlayRate, float RunPlayRate, float MaxWalkSpeed, bool DropPlayRateWhenSmallVel, float DropPlayRateCoef, float MinDropRateValue, float ImpactHandleMoveCoef, bool SyncAnimations);
	static bool MultiDoubleMultiTransitionToAnimFromCurPose_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, class UAnimationAsset* ToNewAsset, float TransitionTime, float PlayFrom, float PlayTill, class UAnimationAsset* FinalAsset, float TransitionTime_final, bool bIsLooping_Final, float InPlayRate, float InStartPosition_Final, float InPlayRate_Final, bool UseSyncGroups_1, bool UseSyncGroups_2);
	static bool MultiTransitionToAnimFromCurPose_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, class UAnimationAsset* AnimationAsset, float TransitionTime, bool bIsLooping, float InPlayRate, bool SyncAnimations, bool CanRestart, bool CanRestartCheckTransition, float TryStartFrom);
	static bool MultiTransitionToMontageFromCurPose_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, class UAnimMontage* AnimationAsset, float TransitionTime, bool bIsLooping, float InPlayRate, class FName PlayFromSection, float StartingPosition, bool CanRestart, bool UseSyncGroups);
	static void PauseAllBlendBoneStacks_BL(class ACharacter* OwnCharacter, float PauseTime, float TransitionTime);
	static void PauseLookAt_BL(class ACharacter* OwnCharacter, bool Stop);
	static void PauseLookAtIfUsedTurnToControlRotation_BL(class ACharacter* OwnCharacter, bool Stop);
	static void PauseToZeroLookAt_BL(class ACharacter* OwnCharacter, bool Stop);
	static void PauseToZeroLookAtIfUsedTurnToControlRotation_BL(class ACharacter* OwnCharacter, bool Stop);
	static EAnimationReturnTypes_DN PivotMachine_BL(class ACharacter* OwnCharacter, class UAnimationAsset* PivotAnimation, float TransitionTime, float AccVelocityDirThreshold, float MinVelocityThreshold, float MinTimeToPlay, const struct FRotator& RotationRateWhenPivot, float AccelerationWhenPivot, bool CalculateDirOnce, bool PlayPivotIfZeroAcc);
	static EAnimationReturnTypes_DN PivotMachineExt_BL(class ACharacter* OwnCharacter, class UAnimationAsset* PivotAnimation, float TransitionTime, float AccVelocityDirThreshold, float MinVelocityThreshold, float MinTimeToPlay, const struct FRotator& RotationRateWhenPivot, float AccelerationWhenPivot, float InterpTime, const struct FRotator& InterpToRotationRateWhenPivot, float InterpToAccelerationWhenPivot, bool CalculateDirOnce, bool PlayPivotIfZeroAcc);
	static void PreSetup_DAZCharacterLegsIK_BL(class ACharacter* OwnCharacter);
	static EAnimationReturnTypes_DN ProneMachine_BL(class ACharacter* OwnCharacter, class UAnimationAsset* StartProneAnimation, class UAnimationAsset* StartProneFromCrouchingAnimation, class UAnimationAsset* IdleAnimation, class UAnimationAsset* EndProneAnimation, class UAnimationAsset* EndProneToCrouchingAnimation, bool UseReverseStartAsEndAnimation, float TransitionTime_To, float TransitionTime_Idle, float TransitionTime_From, float PlayRate, float TransitionTimeQuickReturn);
	static void RebuildNodes_BL(class ACharacter* OwnCharacter, class FName BoneName);
	static void ReleaseAnimationStack_BL(class ACharacter* OwnCharacter, float AdditionalTransitionTime, float CalculatedMinTransitionTime, float CalculatedMaxTransitionTime);
	static void ReleaseAnimationStackAnimFin_BL(class ACharacter* OwnCharacter, float TransitionTime, float TransitionEndOffset);
	static void ReleaseAnimationStackAnimFin_LevelToRelease_BL(class ACharacter* OwnCharacter, float TransitionTime, float TransitionEndOffset, uint8 LevelToRelease);
	static void ReleaseLevelPriorityAnimationStack_BL(class ACharacter* OwnCharacter, uint8 LevelToRelease, float AdditionalTransitionTime, float CalculatedMinTransitionTime, float CalculatedMaxTransitionTime);
	static bool ResetPivot_BL(class ACharacter* OwnCharacter);
	static void ResetStartFromOverrideNextMachine_BL(class ACharacter* OwnCharacter);
	static EAnimationReturnTypes_DN SeatMachine_BL(class ACharacter* OwnCharacter, class UAnimationAsset* SeatDownAnimation, class UAnimationAsset* IdleAnimation, class UAnimationAsset* GetUpAnimation, bool UseReverseStartAsEndAnimation, float TransitionTime_ToSD, float TransitionTime_SIdle, float TransitionTime_GU, float PlayRate, float TransitionTimeQuickReturn);
	static void SetAcclerationCurve_BL(class ACharacter* OwnCharacter, class UAnimationAsset* ForAnimAsset, class UCurveFloat* VelocityAccelerationCurve);
	static bool SetAdditiveBlendSpaceData_BL(class ACharacter* OwnCharacter, const struct FVector& BSData, float IntBSSpeed);
	static void SetAimOffsetAnimationArray_BL(class ACharacter* OwnCharacter, class UBlendSpaceBase* AimOffsetBlendSpace, const TArray<class UAnimationAsset*>& AnimAssetArray, bool ApplyAimAuto);
	static void SetAimOffsetAutoUpdate_BL(class ACharacter* OwnCharacter, const TArray<struct FAnimOffsetAutoUpdateData_DN>& AnimOffsetDataArray);
	static void SetAlphaAnimalRotatorCSLegsIK_BL(class ACharacter* OwnCharacter, int32 LegIndex, float Alpha_Right, float Alpha_Left);
	static void SetAlphaHandsIK_BL(class ACharacter* OwnCharacter, float Alpha);
	static void SetAlphaHandsIKSpecificHand_BL(class ACharacter* OwnCharacter, int32 HandIndex, float TranslationAlpha, float RotationAlpha, float IntSpeedForChangeAlpha);
	static void SetAlphaLegsIK_BL(class ACharacter* OwnCharacter, float Alpha, float IntSpeed);
	static void SetAlphaProneIK_BL(class ACharacter* OwnCharacter, float Alpha, float IntSpeed, bool EnableLegsIK, float LegsMoveBotMulti);
	static void SetAltAlgorithmLegsIK_BL(class ACharacter* OwnCharacter, int32 AltAlgorithmEnable);
	static void SetAnimationCurve_BL(class ACharacter* OwnCharacter, bool UseAccelerationCurve, class FName AccelerationCurveName, bool UseOverrideVelocityCurve, class FName OverrideVelocityCurveName, bool UseMaxSpeedCurve, class FName MaxSpeedCurveName);
	static void SetAnimationStackLimit_BL(class ACharacter* OwnCharacter, bool Enabled, int32 StackPriorityLimit);
	static void SetBS2DModeOneFrame_BL(class ACharacter* OwnCharacter, EBlendSpace2DMode_DN BlendSpace2DMode);
	static void SetBSBlendSpeed_BL(class ACharacter* OwnCharacter, float Speed);
	static void SetBSMapVelocityInputOneFrame_BL(class ACharacter* OwnCharacter, const TArray<float>& MapVelocityData);
	static void SetCurrentStateToFalling_BL(class ACharacter* OwnCharacter);
	static void SetCurrentStateToSwimming_BL(class ACharacter* OwnCharacter);
	static void SetCustomBSDirectionInputOneFrame_BL(class ACharacter* OwnCharacter, float CustomBSDirection);
	static void SetCustomBSVelocityInputOneFrame_BL(class ACharacter* OwnCharacter, float CustomBSVelocity);
	static void SetCustomStatusThisFrame_BL(class ACharacter* OwnCharacter, int32 CustomIndex, bool CustomStatus);
	static void SetDownVectorCSLegsIK_BL(class ACharacter* OwnCharacter, const struct FVector& DownVectorCS, float IntSpeed);
	static void SetEnableLegsIKAllPairs_BL(class ACharacter* OwnCharacter, bool Enable);
	static void SetEnableLegsIKAutoShrinkMode_BL(class ACharacter* OwnCharacter, bool EnableAutoShrinkMode, float ShrinkingModeSpeedCoeff, float ShrinkingModeStartOffsetSec);
	static void SetEnableLegsIKIdleProcessing_BL(class ACharacter* OwnCharacter, bool Enable);
	static void SetEnableLegsIKPairs_BL(class ACharacter* OwnCharacter, const TArray<struct FLegIndexEnabled_DN>& LegIndexEnabled, float BlendSpeed);
	static void SetFootPredictionEnabledLegsIK_BL(class ACharacter* OwnCharacter, bool FootPredictionMode, float FootPredictionCoeff);
	static void SetFootRotationAlphaLegsIK_BL(class ACharacter* OwnCharacter, int32 LegIndex, float LeftLegAlpha, float RightLegAlpha);
	static void SetFootRotationEnableProneIK_BL(class ACharacter* OwnCharacter, int32 LegIndex, bool Enabled);
	static void SetFootRotationParamsLegsIK_BL(class ACharacter* OwnCharacter, int32 LegIndex, float FootClampUpCoeff, float FootAngelClampDegreeBack, float FootAngelClampDegreeForward);
	static void SetForceShareTimeNextTransition_BL(class ACharacter* OwnCharacter, class FName BoneName, bool ForceSkipStartFromAssets);
	static void SetGroundDeltaLegsIK_BL(class ACharacter* OwnCharacter, float GroundDelta, float IntSpeed);
	static void SetGroundDeltaOverrideLegsIK_BL(class ACharacter* OwnCharacter, const TArray<struct FGroundDeltaLegsOverride_DN>& SetGroundOverride);
	static void SetGroundZeroLevelCSLegsIK_BL(class ACharacter* OwnCharacter, bool Enabled, int32 LegIndex, float LegZeroLevelCS_Right, float LegZeroLevelCS_Left);
	static void SetHandsIKRootBones_BL(class ACharacter* OwnCharacter, int32 HandIndex, class FName IkHandBoneName, bool Enable);
	static void SetInstantlyAlphaProneIK_BL(class ACharacter* OwnCharacter, float Alpha, bool EnableLegsIK, float LegsMoveBotMulti);
	static void SetLayStatusThisFrame_BL(class ACharacter* OwnCharacter, bool LieStatus);
	static void SetLegsIKDontMoveBodyMode_BL(class ACharacter* OwnCharacter, bool DontMoveBodyMode, bool ApplyOnlyWnehDownVector);
	static void SetLegsIKLineTraceDistance_BL(class ACharacter* OwnCharacter, float TraceUpValue, float TraceDownValue);
	static void SetLegsIKRootBones_BL(class ACharacter* OwnCharacter, int32 LegIndex, class FName IkFootRightBoneName, class FName IkFootLeftBoneName, bool Enable);
	static void SetLegsIKShrinkAlpha_BL(class ACharacter* OwnCharacter, float ShrinkAlpha);
	static void SetLegsIKTraceChannel_BL(class ACharacter* OwnCharacter, ETraceTypeQuery TraceTypeQuery);
	static void SetLegsIKUseDynamicZPosition_BL(class ACharacter* OwnCharacter, bool UseZDynamic);
	static void SetLevelToReleaseForAnimFin_BL(class ACharacter* OwnCharacter, uint8 LevelToRelease);
	static void SetMaxLiftLegsLegsIK_BL(class ACharacter* OwnCharacter, float MaxLiftLegs);
	static void SetMaxLiftLegsOverrideLegsIK_BL(class ACharacter* OwnCharacter, const TArray<struct FMaxLiftLegsOverride_DN>& MaxLiftLegsOverride);
	static void SetMaxSpeedCurve_BL(class ACharacter* OwnCharacter, class UAnimationAsset* ForAnimAsset, class UCurveFloat* VelocityCurve);
	static void SetMaxSpeedCurveAlpha_BL(class ACharacter* OwnCharacter, float MaxSpeedCurveAlpha);
	static void SetMaxSpeedCurveVelocityDirectionThreshold_BL(class ACharacter* OwnCharacter, float VelocityDirectionThreshold, bool ResetValueIfGoBeyond);
	static void SetNextPoseOfsset_BL(class ACharacter* OwnCharacter, const struct FRotator& AddRootRotation, const struct FVector& AddRootTranslation);
	static void SetNextTransitionTime_BL(class ACharacter* OwnCharacter, float NextTransitionTime, float Timer, bool UseAddToInsteadOfOverriding);
	static void SetNextTransitionTimeOnlyOnce_BL(class ACharacter* OwnCharacter, float NextTransitionTime, float Timer, int32 MaxCount, bool UseAddToInsteadOfOverriding);
	static void SetOffsetAnimalRotatorCSLegsIK_BL(class ACharacter* OwnCharacter, int32 LegIndex, const struct FVector& OffsetAnimalRotatorCS_Right, const struct FVector& OffsetAnimalRotatorCS_Left);
	static void SetPhysicalMaterialCalculationLegsIK_BL(class ACharacter* OwnCharacter, bool CalcEnable);
	static bool SetPlayingForCurrentAsset_BL(class ACharacter* OwnCharacter, class UAnimationAsset* ToSpecificAnimationAsset, bool OnlyForSpecificAnimationAsset, bool bPlaying, class FName BoneName, bool StopMultiTransition);
	static bool SetPlayRateForCurrentAsset_BL(class ACharacter* OwnCharacter, class UAnimationAsset* ToSpecificAnimationAsset, bool OnlyForSpecificAnimationAsset, float PlayRate, class FName BoneName);
	static void SetPlayRateOverrideNextMachine_BL(class ACharacter* OwnCharacter, class UAnimationAsset* Animation, float PlayRate);
	static void SetPluginInfoTimer_DN(class ACharacter* OwnCharacter, float Timer, bool DisableAllInfo);
	static void SetProneIKTraceChannel_BL(class ACharacter* OwnCharacter, ETraceTypeQuery TraceTypeQuery);
	static void SetRearSocketWeightLegsIK_BL(class ACharacter* OwnCharacter, int32 LegIndex, float LeftRearSocketWeight, float RightRearSocketWeight, ERearSocketWeightSlopeType_DN SlopeType);
	static void SetRearSocketWeightProneIK_BL(class ACharacter* OwnCharacter, int32 LegIndex, float LeftRearSocketWeight, float RightRearSocketWeight, ERearSocketWeightSlopeType_DN SlopeType);
	static void SetSeatStatusThisFrame_BL(class ACharacter* OwnCharacter, bool SeatStatus);
	static void SetSeparateMaxLowerRoot_BL(class ACharacter* OwnCharacter, bool Enabled, float SeparateMaxLowerRoot);
	static void SetStartFromMap_BL(class ACharacter* OwnCharacter, class UAnimationAsset* Animation, const TArray<float>& StartFromArray, bool Enabled);
	static void SetStartFromOverrideNextMachine_BL(class ACharacter* OwnCharacter, class UAnimationAsset* Animation, float PlayFrom, bool PlayOnce);
	static void SetTransitionTimeLegsIK_BL(class ACharacter* OwnCharacter, float TransitionTimeLegs, float TransitionTimeLegsRotation, float TransitionTimeRoot, float MovingTransitionCoeff);
	static void SetTurnInPlaceAnimations_BL(class ACharacter* OwnCharacter, class UAnimationAsset* TurnInPlaceLeftAnimation, class UAnimationAsset* TurnInPlaceRightAnimation, float SpeedLimit, float SpeedLimitBlend, float BlendSpeedIn, float BlendSpeedFrom, float ChangeAnimBlendSpeed, float FastBlendSpeedFactor, float MinAngleRotationThredhold, float OneFrameRotationThredhold, bool UseAdaptivePlayRate, float AdaptivePlayRateFactor, float MinAdaptivePlayRateLimit, float MaxAdaptivePlayRateLimit, bool UseAdaptiveAnimationEnd, float AdaptiveAnimationEndYawThreshold, float MaxAlphaWhenMoving);
	static void SetTurnInPlaceAnimationsForAsset_BL(class ACharacter* OwnCharacter, class UAnimationAsset* AnimationAsset, class UAnimationAsset* TurnInPlaceLeftAnimation, class UAnimationAsset* TurnInPlaceRightAnimation, float SpeedLimit, float SpeedLimitBlend, float BlendSpeedIn, float BlendSpeedFrom, float ChangeAnimBlendSpeed, float FastBlendSpeedFactor, float MinAngleRotationThredhold, float OneFrameRotationThredhold, bool UseAdaptivePlayRate, float AdaptivePlayRateFactor, float MinAdaptivePlayRateLimit, float MaxAdaptivePlayRateLimit, bool UseAdaptiveAnimationEnd, float AdaptiveAnimationEndYawThreshold, float MaxAlphaWhenMoving);
	static void SetTurnInPlaceAnimationsOverrideDNMComponent2_BL(class ACharacter* OwnCharacter, class UAnimationAsset* TurnInPlaceLeftAnimation, class UAnimationAsset* TurnInPlaceRightAnimation, float SpeedLimit, float BlendSpeedIn, float BlendSpeedFrom, float ChangeAnimBlendSpeed, float FastBlendSpeedFactor, float PlayRateFixed, bool UseAdaptiveAnimationEnd, float AdaptiveAnimationEndYawThreshold);
	static void SetTurnInPlaceAnimationsOverrideDNMComponent_BL(class ACharacter* OwnCharacter, class UAnimationAsset* TurnInPlaceLeftAnimation, class UAnimationAsset* TurnInPlaceRightAnimation, float SpeedLimit, float BlendSpeedIn, float BlendSpeedFrom, float ChangeAnimBlendSpeed, float FastBlendSpeedFactor, float PlayRateFixed, bool UseAdaptiveAnimationEnd, float AdaptiveAnimationEndYawThreshold);
	static void SetTurnInPlaceAnimationsOverrideDNMComponentForAsset2_BL(class ACharacter* OwnCharacter, class UAnimationAsset* AnimationAsset, class UAnimationAsset* TurnInPlaceLeftAnimation, class UAnimationAsset* TurnInPlaceRightAnimation, float SpeedLimit, float BlendSpeedIn, float BlendSpeedFrom, float ChangeAnimBlendSpeed, float FastBlendSpeedFactor, float PlayRateFixed, bool UseAdaptiveAnimationEnd, float AdaptiveAnimationEndYawThreshold);
	static void SetTurnInPlaceAnimationsOverrideDNMComponentForAsset_BL(class ACharacter* OwnCharacter, class UAnimationAsset* AnimationAsset, class UAnimationAsset* TurnInPlaceLeftAnimation, class UAnimationAsset* TurnInPlaceRightAnimation, float SpeedLimit, float BlendSpeedIn, float BlendSpeedFrom, float ChangeAnimBlendSpeed, float FastBlendSpeedFactor, float PlayRateFixed, bool UseAdaptiveAnimationEnd, float AdaptiveAnimationEndYawThreshold);
	static void SetUpdateFrameRateLegsIK_BL(class ACharacter* OwnCharacter, float UpdateFrameRate);
	static void SetupDelegateOnAnimBlendBoneFinBlend_BL(class ACharacter* OwnCharacter, const TDelegate<void(class UAnimationAsset* Sequence, class FName BoneName)>& AnimBlendBoneFinDelegate);
	static void SetupDelegateOnAnimFinBlend_BL(class ACharacter* OwnCharacter, const TDelegate<void(class UAnimationAsset* Sequence)>& AnimFinDelegate);
	static void SetupHandsCCDIK_BL(class ACharacter* OwnCharacter, const TArray<struct FHandsCCDIKData_DN>& HandsCCDIKData);
	static void SetupHandsIK_BL(class ACharacter* OwnCharacter, const TArray<struct FHandsIKData_DN>& HandsIKData);
	static void SetupLegsIK_BL(class ACharacter* OwnCharacter, const struct FRootLegsPairs_DN& RootLegsPairs, const TArray<struct FRootLegsPairs_DN>& FrontLegsPairs, float UpdateFrameRate, bool FootPredictionMode, float FootPredictionCoeff, bool ShowTraceDebug, bool AlignRootToGround, bool AlignFrontRearPlane, bool LowBodyMode, bool IkLegs, float StairsLegDownCoeff, float FootAngelClampDegree, float FootClampUpCoeff, bool UseRootTrace, float RootTraceRate, float RootTraceAlpha);
	static void SetupLegsIKAnimals_BL(class ACharacter* OwnCharacter, const struct FRootLegsPairs_DN& RootLegsPairs, float UpdateFrameRate, bool FootPredictionMode, float FootPredictionCoeff, bool ShowTraceDebug, bool LowBodyMode, bool IkLegs, float StairsLegDownCoeff, float FootAngelClampDegree, float FootClampUpCoeff);
	static void SetupLegsIKAnimalsSimple_BL(class ACharacter* OwnCharacter, const struct FRootLegsPairsSimple_DN& RootLegsPairs, float UpdateFrameRate, bool FootPredictionMode, float FootPredictionCoeff, bool ShowTraceDebug, bool LowBodyMode, bool IkLegs, float StairsLegDownCoeff);
	static void SetupLegsIKHumanoids_BL(class ACharacter* OwnCharacter, const struct FRootLegsPairs_DN& RootLegsPairs, float UpdateFrameRate, bool FootPredictionMode, float FootPredictionCoeff, bool ShowTraceDebug, float FootAngelClampDegree, float FootClampUpCoeff);
	static void SetupLegsIKSimple_BL(class ACharacter* OwnCharacter, const struct FRootLegsPairsSimple_DN& RootLegsPairs, const TArray<struct FRootLegsPairsSimple_DN>& FrontLegsPairs, float UpdateFrameRate, bool FootPredictionMode, float FootPredictionCoeff, bool ShowTraceDebug, bool AlignRootToGround, bool AlignOnlyFrontRearPlane, bool LowBodyMode, bool IkLegs, float StairsLegDownCoeff, bool UseRootTrace, float RootTraceRate, float RootTraceAlpha);
	static void SetupLegsIKSpiders_BL(class ACharacter* OwnCharacter, const struct FRootLegsPairsSSimple_DN& RootLegsPairsSSimple, float UpdateFrameRate, bool ShowTraceDebug, bool LowBodyMode, bool IkLegs, bool AlignOnlyFrontRearPlane, bool UseRootTrace, float RootTraceRate, float RootTraceAlpha);
	static void SetupLegsIKSpidersSimple_BL(class ACharacter* OwnCharacter, const struct FRootLegsPairsSimple_DN& RootLegsPairs, float UpdateFrameRate, bool ShowTraceDebug, bool LowBodyMode, bool IkLegs, bool AlignOnlyFrontRearPlane, bool UseRootTrace, float RootTraceRate, float RootTraceAlpha);
	static void SetupLegsIKWorms_BL(class ACharacter* OwnCharacter, const struct FRootSSocketPairs_DN& RootSocketsPairs, float UpdateFrameRate, bool ShowTraceDebug, bool AlignOnlyFrontRearPlane, bool UseRootTrace, float RootTraceRate, float RootTraceAlpha);
	static void SetupProneIK_BL(class ACharacter* OwnCharacter, const struct FRootSSocketPairs_DN& RootSocketsPairs, float UpdateFrameRate, bool ShowTraceDebug, bool AlignOnlyFrontRearPlane, float SideAngleClamp, float TotalAngleClamp, const struct FRotator& MeshRotator);
	static void ShiftTracePointLegsIK_BL(class ACharacter* OwnCharacter, int32 LegIndex, const struct FVector& DeltaVectorCSLeft, const struct FVector& DeltaVectorCSRight);
	static float SlopeDetection_BL(class ACharacter* OwnCharacter, ESlopeStatus_DN* SlopeStatus, float RayTraceNomalThreshold, float SlopeUpThresholdIn, float SlopeUpThresholdOut, float SlopeDownThresholdIn, float SlopeDownThresholdOut, float MinTimeOnSlopeToPlay, float SlopeUpMinTimeToPlay, float SlopeDownMinTimeToPlay, float ChangeSlopeDirMinTimeToPlay, float RayDistance, float RayHeightFactor, bool Use4Rays, float Use4RaysHalfWidth, int32 UpdateRate, bool ShowDebug);
	static void StartAnimationStack_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, uint8 StackPriority, class FName BoneName, float BoneBlendAlpha, float BlendTime, bool UseTransitionZones);
	static EAnimationReturnTypes_DN SwimmMachine_BL(class ACharacter* OwnCharacter, class UAnimationAsset* StartSwimmingAnimation, class UAnimationAsset* IdleAnimation, class UAnimationAsset* IdleSurfaceAnimation, class UAnimationAsset* EndSwimmingAnimation, class UAnimationAsset* JumpOutOfWaterAnimation, bool UseOnlyAccelerationForDM, float ShallowWaterImmersionDepth, float SurfaceSwimmImmersionDepth, float OutOfWaterImmersionDepth, float IdlePoseVelocityTreshold, float TransitionTime_ToS, float TransitionTime_SIdle, float TransitionTime_ES, float PlayRate, float TransitionTimeQuickReturn, float PrelandedInWaterAddPlaySec);
	static bool TransitionToAnimFromCurPose_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, class UAnimationAsset* AnimationAsset, float TransitionTime, bool bIsLooping, float InPlayRate, class FName PlayFromNotify, class FName PlayTillNotify, bool CanRestart, float StartFrom);
	static bool TransitionToMontageFromCurPose_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, class UAnimMontage* AnimationAsset, float TransitionTime, bool bIsLooping, float InPlayRate, class FName PlayFromSection, float StartingPosition, bool CanRestart);
	static void TurnToControlRotation_BL(class ACharacter* OwnCharacter, class FName AnchorBone, class FName BoneToRotate, bool UsePinch, float PitchMulti, float PitchUpperGap, float PitchBottomGap, float PitchOffset, float MaxDegrees, float TransitionTime, float RotationAlpha);
	static void UnassignDelegate_AllNotify_BL(class ACharacter* OwnCharacter);
	static void UnassignDelegate_AnimationChange_BL(class ACharacter* OwnCharacter);
	static void UnassignDelegate_SpecificNotify_BL(class ACharacter* OwnCharacter, class FName NotifyName);
	static void UnAssignDelegate_SpecificNotifyAndAsset_BL(class ACharacter* OwnCharacter, class FName NotifyName, const class UAnimSequenceBase* AnimationTrack);
	static bool UnEquipThing_BL(class ACharacter* OwnCharacter, EBranchesOutEnum* Branches, class UAnimationAsset* AnimationToPlay, const TArray<struct FUnEquipThingData_DN>& UnEquipThingData, const TDelegate<void(int32 WeaponIndex, class FName NotifyToAction, bool FinishTransform)>& DelegatesOnComplited, class FName PlayFromNotify, class FName PlayTillNotify, float TransitionTime, float PlayRate, bool CanRestartAnimation);
	static void Update_BL(class ACharacter* OwnCharacter);
	static bool UpdateAimOffset_BL(class ACharacter* OwnCharacter, class FName BoneName, float XVal, float YVal);
	static bool UpdateAimOffsetSmooth_BL(class ACharacter* OwnCharacter, class FName BoneName, float XVal, float YVal, float IntSpeed);
	static void UseMeshSpaceNextBlendBone_BL(class ACharacter* OwnCharacter, bool bMeshSpace);
	static void UseNextIKFunctionFoProneIK_BL(class ACharacter* OwnCharacter);
	static void UseSmoothBlendOut_BL(class ACharacter* OwnCharacter, bool Use);
	static void UseSphereTraceLegsIK_BL(class ACharacter* OwnCharacter, int32 LegIndex, bool UseSphereTrace, float SphereRadius);
	static void UseTurnInPlaceOnlyForSelectedAssets_BL(class ACharacter* OwnCharacter, bool OnlyForSelectedTurnAssets, bool OnlyForSelectedTurnInPlaceAssets);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicNodeBPLibrary">();
	}
	static class UDynamicNodeBPLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicNodeBPLibrary>();
	}
};
static_assert(alignof(UDynamicNodeBPLibrary) == 0x000008, "Wrong alignment on UDynamicNodeBPLibrary");
static_assert(sizeof(UDynamicNodeBPLibrary) == 0x000028, "Wrong size on UDynamicNodeBPLibrary");

}

